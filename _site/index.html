<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Latest Posts &#8211; Rendezvous</title>
<meta name="description" content="Describe this nonsense.">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Latest Posts">
<meta property="og:description" content="Describe this nonsense.">
<meta property="og:url" content="http://localhost:4000/">
<meta property="og:site_name" content="Rendezvous">





<link rel="canonical" href="http://localhost:4000/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Rendezvous Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="BenSuuun photo" class="author-photo">
					<h4>BenSuuun</h4>
					<p>Master student in Data Science at TBSI(Tsinghua-Berkeley Shenzhen Institute)</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:wangbin.sun@yahoo.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/theme-setup/" >Theme Setup</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">External Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/sw.jpg" alt="Latest Posts">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Rendezvous</h1>
      <h2>Latest Posts</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/leetcode-21-to-40/" title="LeetCode #21~#40"><img src="http://localhost:4000/images/abstract-7.jpg" alt="LeetCode #21~#40"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2019-03-09T00:00:00+08:00"><a href="http://localhost:4000/leetcode-21-to-40/">March 09, 2019</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About BenSuuun">BenSuuun</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/leetcode-21-to-40/" rel="bookmark" title="LeetCode #21~#40" itemprop="url">LeetCode #21~#40</a></h1>
    
  </header>
  <div class="entry-content">
    <h2 id="21-merge-two-sorted-lists">#21 Merge Two Sorted Lists</h2>

<h3 id="双链表指针比较">双链表指针比较</h3>
<p>链表上各放置一指针，判断当前位置的大小关系，将较小者加入结果链表。最后，各链表剩余的元素加入结果链表。<br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">l2</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">l1</span> <span class="ow">and</span> <span class="n">l2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">l1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">l2</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="nb">next</span>
        <span class="k">while</span> <span class="n">l1</span><span class="p">:</span>
            <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">l1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="nb">next</span>
        <span class="k">while</span> <span class="n">l2</span><span class="p">:</span>
            <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">l2</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="nb">next</span>
</code></pre></div></div>

<h3 id="tip">Tip</h3>
<ul>
  <li>非空的元素bool判断为真</li>
</ul>

<h2 id="22-generate-parentheses">#22 Generate Parentheses</h2>

<h3 id="模拟栈剪枝">模拟栈剪枝</h3>
<p>模拟一个保存左括号的栈，只有在栈里还有元素时才能出栈并配对右括号。使用深度搜索来便利各种情况，并利用栈来判断是否合法并剪枝<br />
时间$O(n^2)$<br />
空间$O(n^2)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">stackSearch</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">comb</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stackSearch</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">comb</span><span class="o">+</span><span class="s">'('</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">stackSearch</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">comb</span><span class="o">+</span><span class="s">')'</span><span class="p">)</span>
                <span class="n">stackSearch</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">comb</span><span class="o">+</span><span class="s">'('</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stackSearch</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">comb</span><span class="o">+</span><span class="s">')'</span><span class="p">)</span>
        
        <span class="n">stackSearch</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<h3 id="tip-1">Tip</h3>
<ul>
  <li>写类内函数时，注意平行关系的函数间需要加入self。同时，设置类内“全局”变量时也要加上self前缀</li>
  <li>类内函数可以嵌套函数，此时无需加入self,一般对待即可</li>
</ul>

<h2 id="23-merge-k-sorted-lists">#23 Merge k Sorted Lists</h2>

<h3 id="堆优先队列优化">堆/优先队列优化</h3>
<p>维护一个堆结构，每个队列在其中有一个元素，弹出最小元素后，判断其是否有后继，有的话再加入堆并调整结构<br />
时间$O(n\log k)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">heapQueue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heapQueue</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">heapQueue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">heapQueue</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">heapQueue</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heapQueue</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">heapQueue</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">headOutput</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">headOutput</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heapQueue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">heapQueue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span><span class="p">:</span>
                <span class="n">heapQueue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">heapQueue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">heapQueue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">heapQueue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heapQueue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">heapQueue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">heapQueue</span><span class="p">):</span>
                    <span class="n">heapQueue</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">heapQueue</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="n">heapQueue</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">heapQueue</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">heapQueue</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">:</span> 
                        <span class="n">heapQueue</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heapQueue</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">heapQueue</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">heapQueue</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">:</span> 
                        <span class="n">heapQueue</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heapQueue</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">heapQueue</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
                        <span class="k">break</span>
        <span class="k">return</span> <span class="n">headOutput</span><span class="o">.</span><span class="nb">next</span>
</code></pre></div></div>

<h3 id="tip-2">Tip</h3>
<ul>
  <li>python中优先队列可用Queue.PriorityQueue实现，可考虑改写其中部分组块</li>
  <li>考虑输入为空集的情形</li>
  <li>使用List实现类似树结构时，注意下标细节</li>
</ul>

<h2 id="24-swap-nodes-in-pairs">#24 Swap Nodes in Pairs</h2>

<h3 id="逐位交换">逐位交换</h3>
<p>每两位进行交换，逐位进行<br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">swapPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">newHead</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">newHead</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">newHead</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">p1</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p2</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">p0</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">p2</span>
            <span class="n">p2</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">p1</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">p3</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p3</span>
        <span class="k">return</span> <span class="n">newHead</span><span class="o">.</span><span class="nb">next</span>
</code></pre></div></div>

<h3 id="tip-3">Tip</h3>
<ul>
  <li>在进行指针的赋值时，模拟推导注意细节</li>
</ul>

<h2 id="25-reverse-nodes-in-k-group">#25 Reverse Nodes in k-Group</h2>

<h3 id="强制逆序尾部恢复">强制逆序，尾部恢复</h3>
<p>按k的长度逆序，直到访问完全指针。在尾部判断是否逆序了小于k的元素，若是再重新逆序恢复原始顺序。在逆序时，保留上一组的尾指针、这一组的首尾指针便于衔接。<br />
时间$O(n)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseKGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">newHead</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">newHead</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">formerNode</span> <span class="o">=</span> <span class="n">newHead</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">revNode</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">nodeNum</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">lastNode</span> <span class="o">=</span> <span class="n">pointer</span>
            <span class="k">while</span> <span class="n">pointer</span> <span class="ow">and</span> <span class="n">nodeNum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tmpPointer</span> <span class="o">=</span> <span class="n">pointer</span>
                <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span>
                <span class="n">tmpPointer</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">revNode</span>
                <span class="n">revNode</span> <span class="o">=</span> <span class="n">tmpPointer</span>
                <span class="n">nodeNum</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nodeNum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rev2Node</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">lastNode</span> <span class="o">=</span> <span class="n">revNode</span>
                <span class="n">pointer</span> <span class="o">=</span> <span class="n">revNode</span>
                <span class="k">while</span> <span class="n">pointer</span><span class="p">:</span>
                    <span class="n">tmpPointer</span> <span class="o">=</span> <span class="n">pointer</span>
                    <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="nb">next</span>
                    <span class="n">tmpPointer</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">rev2Node</span>
                    <span class="n">rev2Node</span> <span class="o">=</span> <span class="n">tmpPointer</span>
                <span class="n">formerNode</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">rev2Node</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formerNode</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">revNode</span>
                <span class="n">formerNode</span> <span class="o">=</span> <span class="n">lastNode</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">newHead</span><span class="o">.</span><span class="nb">next</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="tip-4">Tip</h3>
<ul>
  <li>在提交代码前，从头至尾浏览一遍发现bug</li>
</ul>

<h2 id="26-remove-duplicates-from-sorted-array">#26 Remove Duplicates from Sorted Array</h2>

<h3 id="逐位判断">逐位判断</h3>
<p>逐位判断，若当前元素和前一元素相等，则删除当前元素<br />
时间$O(n)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">del</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="tip-5">Tip</h3>
<ul>
  <li>函数输入的list时，传入的是reference，函数内修改会影响实际值</li>
</ul>

<h2 id="27-remove-element">#27 Remove Element</h2>

<h3 id="逐位判断-1">逐位判断</h3>
<p>逐位判断，若当前元素等于输入值，删除当前元素<br />
时间$O(n)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="k">del</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="28-implement-strstr">#28 Implement strStr()</h2>

<h3 id="逐位判断-2">逐位判断</h3>
<p>逐位列举needle起始点，判断是否成功<br />
时间$O(nm)$<br />
空间$O(1)$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">strStr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">haystack</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">needle</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">needle</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">haystack</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">needle</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="tip-6">Tip</h3>
<ul>
  <li>检查循环停止条件，注意$\pm 1$的细节</li>
</ul>

<h2 id="29-divide-two-integers">#29 Divide Two Integers</h2>

<h3 id="try异常处理">try异常处理</h3>
<p>存在溢出的可能性，用try监控OverflowError，按要求输出<br />
时间$O(1)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dividend</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">divisor</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dividend</span> <span class="o">/</span> <span class="n">divisor</span>
        <span class="k">except</span> <span class="nb">OverflowError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span> <span class="ow">or</span> <span class="n">result</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="tip-7">Tip</h3>
<ul>
  <li>了解常见的标准异常</li>
  <li>python中的取整函数
    <ul>
      <li>math.floor(), math.ceil() 分别向下和向上取整</li>
      <li>int() 向0取整</li>
      <li>// 计算结果向下取整</li>
      <li>round() 四舍五入，然而由于精度表示影响尽量避免</li>
    </ul>
  </li>
</ul>

<h2 id="30-substring-with-concatenation-of-all-words">#30 Substring with Concatenation of All Words</h2>

<h3 id="x暴力搜索">x暴力搜索</h3>
<p>事先存储每个位置可行的单词编号，随后暴力列举匹配的初始位置，使用深搜来匹配单词串。深搜效率较低，部分测试点超时<br />
时间$O(nm!)$<br />
空间$O(nm)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">validWords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">words</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">wordNo</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)):</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">wordNo</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="k">break</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                    <span class="n">validWords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wordNo</span><span class="p">)</span>
                    
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">pointer</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">wordList</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wordList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">validWords</span><span class="p">[</span><span class="n">pointer</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">wordList</span><span class="p">:</span>
                    <span class="n">wordList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">pointer</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
                        <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">wordList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">remainWords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">remainWords</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="单词定长优化">单词定长优化</h3>
<p>基于暴力搜索方法，有较多的优化点：</p>
<ol>
  <li>单词为定长的，在深搜时无需考虑回溯情况，即同一单词无需考虑前后顺序</li>
  <li>单词匹配可以直接通过是否在List中判断，无需事先通盘计算存储</li>
  <li>字符串可以直接比较，无需逐字符比较</li>
</ol>

<p>时间$O(nm)$<br />
空间$O(m)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">pointer</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">wordList</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wordList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">pointer</span><span class="p">:</span> <span class="n">pointer</span><span class="o">+</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">wordList</span><span class="p">:</span>
                <span class="n">wordList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">pointer</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
                    <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">words</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">([])</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">wordList</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">wordList</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="移动窗口">*移动窗口</h3>
<p>上述算法仍有改进空间：</p>
<ol>
  <li>无需使用函数，其实并未实现深搜</li>
  <li>维护一个窗口，窗口内部完全匹配，另外有一个清单记录配对的单词情况，向右拓宽窗口长度，不合法情况下向右整体移动k个位置；最初只需穷举范围k的起始点即可</li>
</ol>

<p>时间$O(n)$<br />
空间$O(m)$</p>

<h3 id="tip-8">Tip</h3>
<ul>
  <li>不要被DP先入为主，它需要较高空间与初始化算力</li>
  <li>出现不常规的条件时，需要考虑其潜在的作用与优化空间</li>
  <li>注意字符串间比较避免单字符比较</li>
  <li>提前考虑可能的复杂度，并依据复杂度设计算法</li>
</ul>

<h2 id="31-next-permutation">#31 Next Permutation</h2>

<h3 id="数学规律">数学规律</h3>
<p>组合数的字典序有迹可循，由右至左先找到出现下降的位置i，然后在右侧找到一个大于i-1元素的最小元素，将这两个元素交换，随后对i右侧的数进行排序即可<br />
时间$O(n)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">nextPermutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""
        Do not return anything, modify nums in-place instead.
        """</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
</code></pre></div></div>

<h3 id="tip-9">Tip</h3>
<ul>
  <li>在数学规律题中，需要注意细节的$\pm 1$</li>
</ul>

<h2 id="32-longest-valid-parentheses">#32 Longest Valid Parentheses</h2>

<h3 id="基于栈">基于栈</h3>
<p>维护一个待匹配的左括号编号栈，顺序遍历字符串，当出现左括号时加入栈中，出现右括号时出栈一个元素，并计算以该右括号为子串的最终位置的长度情况。<br />
其中需要考虑一些细节：1. 当栈为空而需要匹配一个右括号时，这是非法情况，也就是以该右括号为子串的最终位置的长度是0，但需要另一个变量更新其位置作“新串初始位置”。2. 当出栈一个元素后，栈为空，无法直接计算长度，需要利用先前存储的“初始位置”来作差计算<br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestValidParentheses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">output</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">line</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="o">==</span> <span class="s">'('</span><span class="p">:</span>
                <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span>
                <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">pointer</span>
                    <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
                        <span class="n">output</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">pointer</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">output</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">pointer</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                    <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">1</span>               
        <span class="k">return</span> <span class="n">output</span>         
</code></pre></div></div>

<h3 id="tip-10">Tip</h3>
<ul>
  <li>考虑常见的处理方式</li>
</ul>

<h2 id="33-search-in-rotated-sorted-array">#33 Search in Rotated Sorted Array</h2>

<h3 id="二分查找">二分查找</h3>
<p>若要达到题设的复杂度，二分查找是必然选择。经过模拟推导，可以将原本的二分查找规则进行适当改变，加入一系列判断条件分支来完成查询。以下，i,j表示数组两端的值，k是数组二分的值（向下取整），x为目标值，通用其具体的下标表示和值。</p>
<ul>
  <li>i &gt; j （存在断层的数组）
    <ul>
      <li>k &gt;= i （二分值在左段）
        <ul>
          <li>x &gt; k or x &lt; i: f(k, j)</li>
          <li>i &lt; x &lt; k: f(i, k)</li>
        </ul>
      </li>
      <li>k &lt; j （二分值在右段）
        <ul>
          <li>x &gt; j or x &lt; k: f(i, k)</li>
          <li>k &lt; x &lt; j: f(k, j)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>i &lt; j （正常的二分查找即可）
    <ul>
      <li>x &gt; k: f(k, j)</li>
      <li>x &lt; k: f(i, k)</li>
    </ul>
  </li>
  <li>i = j （不存在重复值，非法）</li>
</ul>

<p>时间$O(\log n)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">bs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">k</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">or</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">return</span> <span class="n">bs</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">bs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="k">return</span> <span class="n">bs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">bs</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">bs</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">bs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="tip-11">Tip</h3>
<ul>
  <li>需要考虑递归最后的基表示细节
    <ul>
      <li>这里是当只有两个元素时，需要检查二分值等的情况来合理归类</li>
    </ul>
  </li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/notes-deep-learning/" title="Notes-Deep Learning"><img src="http://localhost:4000/images/abstract-4.jpg" alt="Notes-Deep Learning"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2019-02-26T00:00:00+08:00"><a href="http://localhost:4000/notes-deep-learning/">February 26, 2019</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About BenSuuun">BenSuuun</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/notes-deep-learning/" rel="bookmark" title="Notes-Deep Learning" itemprop="url">Notes-Deep Learning</a></h1>
    
  </header>
  <div class="entry-content">
    <h2 id="notes-of-deep-learning-by-ian-goodfellow-yoshua-bengio-and-aaron-courville">Notes of “Deep Learning” by Ian Goodfellow, Yoshua Bengio and Aaron Courville</h2>

<h1 id="chap-1-introduction">Chap. 1 Introduction</h1>
<ul>
  <li>[Solution towards AI] It allows computers to learn from experience and understands the world in terms of <strong>a hierarchy of concepts</strong>, with each concept defined through its relation to simpler concepts</li>
  <li>[Crucial components in Machine Learning] the representation of the data they are given, or called “Feature”
    <ul>
      <li>[Representation Learning]  Use machine learning to discover not only the mapping from representation to output but also the representation itself.</li>
    </ul>
  </li>
  <li>[Historical Wave] cybernetics -&gt; connectionism + neural networks -&gt; deep learning</li>
</ul>

<h1 id="chap-4-numerical-computation">Chap. 4 Numerical Computation</h1>
<ul>
  <li>[Poor condition] For $A\in R^{n\times n}$, its condition number is $max_{i,j}(| \frac{ \lambda _i}{\lambda _j} |)$.When this number is large, matrix inversion is particularly sensitive to error in the input.</li>
  <li>[order of optimizaiton] Optimization algorithms that use only the gradient, such as gradient descent, are called first-order optimization algorithms. Optimization algorithms that also use the Hessian matrix, such as Newton’s method, are called second-order optimization algorithms</li>
</ul>

<h2 id="problem-4">PROBLEM-4</h2>
<ul>
  <li>牛顿法矩阵形式推导？
    <ul>
      <li>牛顿法本质是求解一函数的零点，延伸到这里，求解一阶导数的零点相当于寻找最值。证明可利用“图解”或者二阶泰勒展开。</li>
    </ul>
  </li>
  <li>KKT条件的推导？
    <ul>
      <li>强调互补松弛性</li>
    </ul>
  </li>
</ul>

<h1 id="chap-6-deep-feedforward-networks">Chap. 6 Deep Feedforward Networks</h1>
<ul>
  <li>[Deep Feedforward Networks] also called feedforward neural networks or multilayer perceptrons (MLPs). It does not have feedback connections</li>
  <li>[Choose mapping $\phi$ options]
    <ul>
      <li>It should be generic, avoiding overfitting</li>
      <li>Manually engineer in conventional way</li>
      <li>As for deep learning, it is learned</li>
    </ul>
  </li>
  <li>[Nonlinear transformation] usually followed by a fixed nonlinear function called an activation function</li>
  <li>[Learning component] like machine learning, including optimizaiton procedure, cost function and model familiy
    <ul>
      <li>Difference in optimization, loss function will be nonconvex due to nonlinear propertity of units, so iterative method required</li>
    </ul>
  </li>
  <li>[Gradient-Based Learning] No global convengency assured, and initial parameters are crucial
    <ul>
      <li>Maximum cross entropy simplifies the choosing of cost function</li>
      <li>Negative log-likelihood helps to solve vanishing gradient problem</li>
      <li>mean squared error and mean absolute error often lead to poor results when used with gradient-based optimization</li>
    </ul>
  </li>
  <li>[Output Units] Linear, Sigmoid, Softmax, Other</li>
  <li>[Hidden Units] ReLU is widely used(without much consideration)
    <ul>
      <li>Although at 0 it is not differentiable, it doesn’t matter as objective won’t arrive it</li>
      <li>Most only distinguish on activation function</li>
      <li>[Maxout units] Divide the input into k groups and output the maximum.</li>
      <li>Before ReLU, logistic sigmoid and hyperbolic tangent is used as activation function</li>
    </ul>
  </li>
  <li>[Architecture] main consideration is on depth and width
    <ul>
      <li>[Universal Approximation Properties] a feedforward network introduced here can approximate any Borel measurable function</li>
      <li>Two core process, learn and generalize</li>
      <li>Hidden lay with activation function can be regared as “fold” the complex space
        <ul>
          <li>In general, deep model leads to high generalization</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>[Backpropagation] Information flow back to help calculate the gradient
    <ul>
      <li>Not only vectors, all tensors can use this method</li>
      <li>it performs on the order of one Jacobian product per node in the graph</li>
      <li>Two categories: symbol-to-symbol and symbol-to-numeric, the former introduces the computational graph</li>
      <li>It is a table-filling strategy, a.k.a., dynamic programming</li>
    </ul>
  </li>
</ul>

<h2 id="problem-6">PROBLEM-6</h2>
<ul>
  <li>Cross-entropy的计算与其本质，与条件熵的区别？交叉熵比MSE好在哪里？
    <ul>
      <li>D(p| | q) = H(p) + 交叉熵H(p,q)。最小化DL Divergence等同于最小化交叉熵。</li>
    </ul>
  </li>
  <li>为什么最大似然估计能够学习条件概率？
    <ul>
      <li>本身就以条件概率的形式表示</li>
    </ul>
  </li>
  <li>线性单元输出为何能表示高斯分布？为什么最大化log似然与最小化MSE等价？
    <ul>
      <li>min -Elog(y| x) 可推导成 min E(y - y^)^2</li>
    </ul>
  </li>
  <li>混合密度网络是如何学习的？其中的高斯分布、协方差矩阵、精度矩阵有什么关系？
    <ul>
      <li>A: $N(x;\mu;\sigma^2) = \sqrt{\frac{1}{2\pi\sigma^2}}exp(-\frac{1}{2\sigma^2}(x-\mu)^2)$ 高斯分布需要求标准差平方的倒数，引入精度$\beta\in(0,\infty)$避免计算，原本的分布转变成$N(x;\mu;\beta^{-1}) = \sqrt{\frac{\beta}{2\pi}}exp(-\frac{1}{2}\beta(x-\mu)^2)$。多维高斯分布的协方差矩阵同样可转变成精度矩阵，更为高效，无需求逆。由$N(x;\mu;\Sigma) = \sqrt{\frac{1}{(2\pi)^ndet(\Sigma)}}exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))$转变成$N(x;\mu;\beta^{-1}) = \sqrt{\frac{det(\beta)}{(2\pi)^n}}exp(-\frac{1}{2}(x-\mu)^T\beta(x-\mu))$</li>
    </ul>
  </li>
  <li>矩阵表示的反向传播推导？
    <ul>
      <li>存储中间计算的梯度，用于前一层梯度的传递</li>
    </ul>
  </li>
  <li>Hessian矩阵在深度学习的应用，另外Krylov方法是？
    <ul>
      <li>A: H矩阵可以应用于泰勒级数。 Krylov可以迭代近似求解矩阵的逆、特征值、特征向量（只利用矩阵乘法）</li>
    </ul>
  </li>
  <li>矩阵求导如何定义？
    <ul>
      <li>基本上是逐元素进行，关键是考虑其排列的方式</li>
    </ul>
  </li>
  <li>6.23公式-令y=1/0代入可推导</li>
</ul>

<h1 id="chap-7-regularization-for-deep-learning">Chap. 7 Regularization for Deep Learning</h1>
<ul>
  <li>[Nature of Regularization] Regularization of an estimator works by trading increased bias for reduced variance.</li>
  <li>[Parameter penalties] Only the weights are imposed penalty, leaving the bias. The bias controls a single variable, the penalty on it may cause under-fitting.
    <ul>
      <li>[$L^2$ Regularization] a.k.a., weight decay. Other communities name it ridge regression or Tikhonov regularization.
        <ul>
          <li>Decay is along the eigenvector(OF H), the scaling factor is $\frac{\lambda_i}{\lambda_i+\alpha}$, the decay effect is less significant on larger $\lambda_i$.</li>
          <li>L2 regularization causes the learning algorithm to “perceive” the input X as having higher variance</li>
        </ul>
      </li>
      <li>[$L^1$ Regularization] generating more sparse solution, so it can be used to select feature (eg. LASSO)</li>
      <li>Too much weight decay will trap the network in a bad local minimum</li>
    </ul>
  </li>
  <li>[Dataset augmentation] Injecting noise in the input also works
    <ul>
      <li>It makes the model more robust.</li>
      <li>Label smoothing is imposing on the output, functioning as regularization</li>
    </ul>
  </li>
  <li>[Sparse Representation] Place a penalty on the activations of the units in a neural network, encouraging their activations to be sparse.
    <ul>
      <li>Mechanism is the same as parameter regularization, imposing penalty on objective function($\Omega(h)$)</li>
    </ul>
  </li>
  <li>[Ensemble techniques] combining several models to achieve low generalization error.
    <ul>
      <li>Bagging (short for bootstrap aggregating), helps regularization</li>
      <li>Boosting, on the contrary, drives the capacity up.</li>
    </ul>
  </li>
  <li>[Dropout] Similar to bagging,  it provides a computationally inexpensive but powerful method of regularizing a broad family of models
    <ul>
      <li>take advantage of shared weight from parental structure.</li>
      <li>[weight scaling inference rule] approximate $p_{ensemble}$ by evaluating $p(y| x)$ in the model with all units, then multiply the weight with the probability of including the unit.
        <ul>
          <li>ensure that the expected total input to a unit at test time is roughly the same as the expected total input to that unit at train time</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>[Adversarial training]  explicitly introduce a local constancy prior into supervised neural nets.</li>
</ul>

<h2 id="problem-7">PROBLEM-7</h2>
<ul>
  <li>Weight-decay中最优权重的推导与无正则条件下的对比 ;L1解析解的结论推导
    <ul>
      <li>利用泰勒展开拟合最优点的二次曲线，讨论权重的表达式。对于L1，同样可利用泰勒公式，通过一定假设大致说明其稀疏性的结论</li>
    </ul>
  </li>
  <li>reproject重投影与参数惩罚、显式约束的关系？
    <ul>
      <li>重投影是和梯度下降算法相关的</li>
    </ul>
  </li>
  <li>半监督学习中，生成模型、判别模型的关系？参数共享的含义是什么？
    <ul>
      <li>生成模型x,y，判别模型y| x；半监督通常是表示学习</li>
    </ul>
  </li>
  <li>Early stopping 与 L2 regularization的关系推导？
    <ul>
      <li>Early stopping相当与在逼近无正则化的最优点过程中停下，停留的点为L2下的最优点 (参数选择满足一定条件)</li>
    </ul>
  </li>
  <li>流形的含义是什么，正切传播、双反向传播和对抗训练的关系是什么？
    <ul>
      <li>将聚集的点想像成流形面？可以计算切线之类的……不使用欧式距离来定义</li>
    </ul>
  </li>
  <li>整理可以应用的正则表达工具包
    <ul>
      <li>见目录</li>
    </ul>
  </li>
</ul>

<h1 id="chap-8-optimization-for-training-deep-models">Chap. 8 Optimization for Training Deep Models</h1>
<ul>
  <li>[Difference]We reduce a different cost function $J(\theta)$ in the hope that doing so will improve P. It is indirect.
    <ul>
      <li>We hope to minimize the expectation on the data-generating distribution $p_{data}$: $J^*(\theta) = E_{(x,y)\sim p_{data}}L(f(x;\theta),y)$</li>
      <li>However, the true distribution is unknown, so we can only minimize empirical risk instead, which may easily lead to overfitting</li>
    </ul>
  </li>
  <li>[Challenge in Optimization] Optimization problem may be non-convex.
    <ul>
      <li>Ill-condition Hessian matrix</li>
      <li>Model identifiability issues mean that a neural network cost function can have an extremely large or even uncountably infinite amount of local minima.</li>
      <li>For many random functions, in low- dimensional spaces, local minima are common. In higher-dimensional spaces, local minima are rare, and saddle points are more common.
        <ul>
          <li>Commonly, saddle points have higher cost than local minima</li>
          <li>Newton method is not suitable, as it finds the point where the gradient is zero</li>
        </ul>
      </li>
      <li>Using gradient clipping to avoid cliffs with exploding gradients</li>
      <li>Choose appropriate surrogate loss function to approximate true loss, and can be more accurately estimated</li>
    </ul>
  </li>
  <li>[Basic algorithm]
    <ul>
      <li>[SGD]Learning rate should be smaller as the training process goes
        <ul>
          <li>In practice, on iteration $\tau$,$\epsilon_k = (1-\alpha)\epsilon_0+\alpha\epsilon_\tau$,$\alpha = \frac{k}{\tau}$</li>
        </ul>
      </li>
      <li>[Momentum] SGD is kind of slow, this method is aimed to accelerate learning.
        <ul>
          <li>It solves two problems: poor conditioning of the Hessian matrix and variance in the stochastic gradient</li>
          <li>It accumulates the former gradient</li>
          <li>Nesterov momentum method apply the current velocity before the gradient evaluated</li>
        </ul>
      </li>
      <li>For adapative learning rates algorithms, not much theoretical difference.</li>
    </ul>
  </li>
  <li>[Newton method] Approximate the point using 2-order Taloy formular. Calculating the inverse of H as the updating value
    <ul>
      <li>Utilizing conjugate directions to avoid calculating inversion
        <ul>
          <li>the seaching direction has to be vertical agaist the former one</li>
        </ul>
      </li>
      <li>BFGS takes advantage of newton method, while overcomte its shortage(inversion calculation), it performs better on time but memory is required more</li>
    </ul>
  </li>
  <li>[block coordinate decent] Optimize the variable in term, when there’s more than one optimization variable and the function has good properties like convex</li>
</ul>

<h2 id="problem-8">PROBLEM-8</h2>
<ul>
  <li>Hessian矩阵在优化中的应用，ill-condition的含义是什么？牛顿法的应用
    <ul>
      <li>Hessian就是二阶导数。病态条件使得梯度卡住，梯度不会显著缩小，但二次项增长会超过一个数量级。</li>
    </ul>
  </li>
  <li>鞍点的梯度定义是什么？
    <ul>
      <li>梯度为0，但Hessian矩阵有正负特征值</li>
    </ul>
  </li>
  <li>理解Adam算法，矩阶数、偏置修正等
    <ul>
      <li>引入指数加权、一二阶矩估计，并修正偏差</li>
    </ul>
  </li>
  <li>整理可以应用的优化方法工具包
    <ul>
      <li>看目录</li>
    </ul>
  </li>
</ul>

<h1 id="chap-9-convolutional-networks">Chap. 9 Convolutional Networks</h1>
<ul>
  <li>[Convolution operation]x and w are the function of t, $s(t) = (x * w)(t) = \int{x(a)w(t-a)}da$</li>
  <li>[Motivation] sparse interactions, parameter sharing and equivariant representations are three import ideas by convoution
    <ul>
      <li>[sparse interactions] instead of full connection, node only inteacts with limited number of nodes in the next layer. This leads to the phenonmenan that deep node has a high receptive field, although the connection is indirect.</li>
      <li>[parameter sharing] the weight matrix is shared between nodes and layers, which reduce the number of parameters to be estimated</li>
      <li>[equivariant representations] the input changes, the output changes in the same way. A function f(x) is equivariant to a function g if f(g(x)) = g(f(x))</li>
    </ul>
  </li>
  <li>[pooling] a typical layer consists of three stages: convolution stage, detector stage and pooling stage
    <ul>
      <li>pooling helps to make the representation invariant. Invariance to local translation identifies the significant feature while discard the location information</li>
      <li>Pooling is able to deal with input with different dimension. Summarize the input and it can output the same dimension.</li>
    </ul>
  </li>
  <li>[Downsampling] sample only every s(called “stride”) pixels in each direction in the output</li>
  <li>[Weight sharing] locally connected layers: no sharing at all; tiled convolution: a sharing list cycling; tranditional convolution: all sharing</li>
</ul>

<h2 id="problem-9">PROBLEM-9</h2>
<ul>
  <li>在进行convolution, ReLU和pooling后，特征维度的变化是怎么样的？如何选取卷积层的核？卷积层和仿射变换是什么关系？
    <ul>
      <li>https://zhuanlan.zhihu.com/p/29119239</li>
    </ul>
  </li>
  <li>卷积层的矩阵表示，及反向传播参数推导？
    <ul>
      <li>反向传播，核心是一致的</li>
    </ul>
  </li>
</ul>

<h1 id="chap-10-sequence-modeling-recurrent-and-recursive-nets-">Chap. 10 Sequence Modeling: Recurrent and Recursive Nets ***</h1>
<ul>
  <li>[Weight in RNN] Parameter sharing makes it possible to extend and apply the model to examples of different forms</li>
  <li>[Back-propagation through time(BPTT)] applied to the unrolled graph with O($\tau$) cost, with connections between hidden layers</li>
  <li>[Teacher Forcing] Models that have recurrent connections from their outputs leading back into the model may be trained with Teacher Forcing</li>
  <li>The price recurrent networks pay for their reduced number of parameters is that optimizing the parameters may be difficult.</li>
  <li>[Bidirectional RNNs] we want to output a prediction of y(t) that may depend on the whole input sequence.
    <ul>
      <li>Hidden layers are seperated as two direction</li>
    </ul>
  </li>
  <li>[Recursive Neural Networks] It is a tree structure, rather than simple chain structure like RNN. Actually, it extends the original RNN idea.</li>
  <li>[Main challenge] Long-term dependence, which means that gradients propagated over many stages tend to either vanish (most of te time) or explode (rarely, but with much damage to the optimization). It is more significant in the RNN structure.</li>
  <li>[Reservoir computing] e.g. “echo state networks”. The recurrent hidden units do a good job of capturing the history of past inputs, and only learn the output weights.
    <ul>
      <li>As the input matrix and hidden layer matrix are difficult to learn</li>
      <li>Spectral radius is the maximum absolute eigenvalue of Jacobians. It measure the scaling factor.</li>
    </ul>
  </li>
  <li>[Gated recurrent unit] create paths through time that have derivatives that neither vanish nor explode.
    <ul>
      <li>Leaky units manually choose constant or set them as parameters. Gated RNNs generalize this to connection weights that may change at each time step.</li>
      <li>[LSTM cell] LSTM recurrent networks have “LSTM cells” that have an internal recurrence (a self-loop)
        <ul>
          <li>Including forget gate, external input gate, output gate</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="problem-10">PROBLEM-10</h2>
<ul>
  <li>BPTT和Teacher Forcing的核心区别是什么？为什么计算时间会不同？如何将这两个训练方法结合起来？</li>
  <li>BPTT的矩阵梯度传播推导</li>
  <li>为什么基于上下文时，模型会出现如此调整？context含义是什么？</li>
  <li>已有架构的梳理，输入长度？输出长度？</li>
  <li>谱半径的理解，反向传播中扰动的意义？扰动的缩放含义是？</li>
  <li>回声状态网络中，动态系统如何应用？Jacobian矩阵的角色是什么？</li>
  <li>LSTM矩阵表示推导？结构整理</li>
  <li>RNN优化的核心，解决长期依赖问题的整理？包括梯度爆炸和梯度消失</li>
  <li>基于外显记忆的NTM是如何实现的，如何评估记忆单元？</li>
</ul>

<h1 id="chap-11-practical-methogology">Chap. 11 Practical Methogology</h1>
<ul>
  <li>[Recommended Procedure] Determine the goal -&gt; Estabilish a pipeline -&gt; Instrument the system -&gt; Iteratively make changes</li>
  <li>[Performance Metrics] Choose the ideal level of performance; choose the metric used
    <ul>
      <li>PR curve is used when precision and recall are calculated</li>
    </ul>
  </li>
  <li>[Parameter tuning]
    <ul>
      <li>[Manually] Effective capacity constrained by :the representational capacity of the model, the ability of the learning algorithm to successfully minimize the cost function used to train the model, and the degree to which the cost function and training procedure regularize the model
        <ul>
          <li>Learning rate is the most important hyper-parameter</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="problem-11">PROBLEM-11</h2>
<ul>
  <li>总结实践的方法，注意细节点？</li>
</ul>

<h1 id="chap-12-application">Chap. 12 Application</h1>
<ul>
  <li>[Large Scale Learning]
    <ul>
      <li>[GPU] have a high degree of parallelism and high memory bandwidth, at the cost of having a lower clock speed and less branching capability relative to traditional CPUs.</li>
      <li>[asynchronous stochastic gradient descent]  allow multiple machines to compute multiple gradient descent steps in parallel</li>
      <li>[Dynamic Structure]  Data-processing systems can dynamically determine which subset of many neural networks should be run on a given input
        <ul>
          <li>use a cascade of classifiers</li>
          <li>use a neural network called the gater</li>
          <li>use a switch</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>[Computor Vision]
    <ul>
      <li>[Preprocession]
        <ul>
          <li>[Contrast Normalization] includes Global contrast normalization (project the data point to a sphere) , sphering (or whitening) and Local contrast normalizaiton(focus on the edges)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>[Speech Recognition]
    <ul>
      <li>[Classic Models] HMM, GMM, RBMs</li>
    </ul>
  </li>
  <li>[Natural Language Processing]
    <ul>
      <li>[n-gram] requries smoothing</li>
      <li>[word embedding] a kind of neural language model(NLM)</li>
      <li>[High dimensional outputs]
        <ul>
          <li>Use of a Short List</li>
          <li>Hierarchical Softmax</li>
          <li>Importance Sampling
            <ul>
              <li>not only useful for speeding up models with large softmax outputs. More generally, it is useful for accelerating training with large sparse output layers</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="problem-12">PROBLEM-12</h2>
<ul>
  <li>分层SoftMax的机制是什么？如何展开训练？对于模型的影响有哪些？（联想到了huffman编码）</li>
  <li>重要采样的公式理解与实现？重要采样对于稀疏向量处理的优势？
    <ul>
      <li>softmax更快采样</li>
      <li>n-gram的例子含义</li>
    </ul>
  </li>
</ul>

<h1 id="chap-13-linear-factor-models">Chap. 13 Linear Factor Models</h1>
<ul>
  <li>[Linear Factor Model] the use of a stochastic linear decoder function that generates x by adding noise to a linear transformation of h.
    <ul>
      <li>Different models make differenet choices about the noise and the prior p(h)</li>
    </ul>
  </li>
  <li>[Probabilistic PCA] Assume the conditional variances equal to each other, i.e., the nose is a multivariate Gaussian noise.
    <ul>
      <li>most variations in the data can be captured by the latent variables h, up to some small residual reconstruction error $\sigma^2$</li>
      <li>probabilistic PCA becomes PCA as $\sigma \to 0$.</li>
    </ul>
  </li>
  <li>[Independent Component Analysis] Model linear factors that seeks to separate an observed signal (fully independent) into many underlying signals that are scaled and added together to form the observed data.</li>
  <li>[Slow Feature Analysis] a linear factor model that uses information from time signals to learn invariant features
    <ul>
      <li>[Slowness Principle] the important characteristics of scenes change very slowly compared to the individual measurements that make up a description of a scene.</li>
    </ul>
  </li>
  <li>[Sparse coding]  an unsupervised feature learning and feature extraction mechanism
    <ul>
      <li>Sparse coding is not a parametric autoencoder.</li>
    </ul>
  </li>
</ul>

<h2 id="problem-13">PROBLEM-13</h2>
<ul>
  <li>主成分分析的矩阵推导（第二章）？</li>
  <li>PCA中，x的高斯分布参数推导？PCA是去掉噪声的因子分析吗？需要对于线性变换有秩的要求吗？</li>
  <li>PCA、概率PCA的关系？
    <ul>
      <li>A：PCA是将x进行线性组合，构造分量x’；而概率PCA是基于因子分析的内容，因子分析是寻找潜分量h，使得h的线性组合加上噪声等于x，而概率PCA则是令噪声的方差等于0。</li>
    </ul>
  </li>
  <li>为什么在ICA中不用高斯分布，W会遇到什么问题？
    <ul>
      <li>因为高斯的线性组合仍然是高斯，所以分解不唯一。ICA的目求出W</li>
    </ul>
  </li>
  <li>为什么稀疏编码不能使用最大似然法训练模型？</li>
  <li>稀疏编码如何推导至L1范数的优化目标？</li>
  <li>生成模型的含义？
    <ul>
      <li>联合概率；判别模型是条件概率</li>
    </ul>
  </li>
</ul>

<h1 id="chap-14-autoencoders">Chap. 14 Autoencoders</h1>
<ul>
  <li>[autoencoder] a neural network that is trained to attempt to copy its input to its output
    <ul>
      <li>two parts: an encoder function h = f(x) and a decoder that produces a reconstruction r = g(h).</li>
    </ul>
  </li>
  <li>[undercomplete autoencoder] code dimension is less than the input dimension</li>
  <li>[Regularized autoencoder] use a loss function that encourages the model to have other properties besides the ability to copy its input to its output
    <ul>
      <li>[Sparse autoencoder] impose a sparsity penalty, although it is different from weight decay</li>
      <li>[Denoising autoencoder (DAE)] noise is added into input, and DAE must eliminate the noise itself
        <ul>
          <li>By sampling, learn the distribution</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>[contractive autoencoder] Regularize the derivative of f</li>
  <li>[Predictive sparse decomposition]  a hybrid of sparse coding and parametric autoencoders</li>
  <li>Autoencoder can be applied in dimensionality reduction, which will benefit informaiton retrieval tasks, classification tasks</li>
</ul>

<h2 id="problem-14">PROBLEM-14</h2>
<ul>
  <li>MAP 近似贝叶斯推断是什么含义？为什么前馈网络的权重衰减属于这一类？正则自编码器的正则为何含义不同？</li>
  <li>随机编码器、随机解码器的核心是什么？引入的概率分布与其他自编码器有什么区别？</li>
  <li>DAE的loss function为何是-log
    <ul>
      <li>最大似然？</li>
    </ul>
  </li>
  <li>基于RBM的模型和去噪得分匹配的关系是什么？自编码器又有什么关系？为何重构函数是g(f(x))</li>
  <li>自编码器与流形学习之间的关系</li>
  <li>非参模型、分布式表示、深度学习捕获流形结构的区别</li>
  <li>CAE感觉有点类似泰勒展开，用线性拟合非线性？</li>
  <li>正则自编码器的两股力量推动学习，不同自模型似乎不太一样？</li>
</ul>

<h1 id="chap-15-representation-learning">Chap. 15 Representation Learning</h1>

<ul>
  <li>Shared presentation benefits the learning process
    <ul>
      <li>The core idea of representation learning is that the same representation may be useful in both settings.</li>
    </ul>
  </li>
  <li>[Greedy layer-wise unsupervised pretraining] a representation learned for one task can sometimes be useful for another task
    <ul>
      <li>Every layer is optimized individually</li>
      <li>In supervised learning, it can be viewed as a regularizer and a form of parameter initialization</li>
      <li>Unsupervised pretraining contains massive hyper-parameters, which cannot show effect before supervised learning</li>
      <li>Nowadays, apart form NLP, most algorithms do not contain this part</li>
      <li>Unsupervised pretraining extends to supervised pretraining</li>
    </ul>
  </li>
  <li>[Transfer learning] similar as multi-task learning, sharing input structure or output structure</li>
  <li>Many deep learning algorithms are motivated by the assumption that the hidden units can learn to represent the underlying causal factors that explain the data</li>
  <li>[Distributed representation] different from symbolic one as it can generalize due to shared attributes
    <ul>
      <li>nondistributed models generalize only locally via the smoothness prior, making it difficult to learn a complicated function with more peaks and troughs than the available number of examples</li>
      <li>information exists between labels, and they are not “atom”s but combinition of hidden features</li>
    </ul>
  </li>
</ul>

<h2 id="problem-15">Problem-15</h2>

<ul>
  <li>为什么具有更多独立性的分布更容易建模？</li>
  <li>表示学习中贝叶斯相关的概率理解？或者说核心？因果因子和解释因子的本质区别？</li>
  <li>通用正则化策略，与前面章节的正则化有区别吗？
    <ul>
      <li>似乎这里更偏向表示学习？</li>
    </ul>
  </li>
</ul>

<h1 id="chap16-structured-probabilistic-models-for-deep-learning">Chap.16 Structured Probabilistic Models for Deep Learning</h1>

<ul>
  <li>[structured probabilistic model] describe a probability distribution, using a graph to describe which random variables in the probability distribution interact with each other directly.</li>
  <li>Structured probabilistic models provide a formal framework for modeling only direct interactions between random variables.
    <ul>
      <li>reduces the number of parameters and computational cost during model storage, model inference and model sampling</li>
    </ul>
  </li>
  <li>[Directed models] As long as each variable has few parents in the graph, the distribution can be represented with very few parameters.</li>
  <li>[Undirected models] Edge exists when two variables affect each other without direction
    <ul>
      <li>Z is usually intractable in the context of deep learning</li>
    </ul>
  </li>
  <li>We want to choose a graph that implies as many independences as possible, without implying any independences that do not actually exist.</li>
  <li>[Ancestral Sampling] directed graphical models has a a simple and efficient procedure to produce a sample from the joint distribution represented by the model</li>
  <li>The primary advantage of using structured probabilistic models is that they allow us to dramatically reduce the cost of representing probability distributions as well as learning and inference.</li>
  <li>Use latent variable to reduce complexity. Latent variables have advantages in efficiently capturing p(v).</li>
  <li>Approximate inference is applied,, as the complexity in deep learning, even using probabilistic graph to represent it.</li>
  <li>Latent variables are given certain meaning in the traditional graph model, while in deep learning they have no pre-definition
    <ul>
      <li>Traditional approaches to graphical models typically aim to maintain the tractability of exact inference.</li>
    </ul>
  </li>
</ul>

<h2 id="problem-16">Problem-16</h2>

<ul>
  <li>有向图采样时，为什么存在“其他变量”的影响？如何理解</li>
</ul>

<h1 id="chap17-monte-carlo-methods">Chap.17 Monte Carlo Methods</h1>

<ul>
  <li>deterministic approximate algorithms or Monte Carlo approximations are used in machine learning</li>
  <li>The variance of importance sampling is sensitive to distribution q</li>
  <li>In deep learning, when p(x) is undirected model, it is hard to find a good importance sampling q(x)
    <ul>
      <li>[Markov Chain Monte Carlo] using energy-based model to sample
        <ul>
          <li>use markov chain to avoid “chicken-and-egg problem” in undirected graph.</li>
          <li>Ancestral sampling is a topological way to implement</li>
          <li>MCMC has large time cost, especially for burning-in and avoiding relevant samples</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>MCMC easily stuck on one mode
    <ul>
      <li>using tempering to mix</li>
    </ul>
  </li>
</ul>

<h2 id="problem-17">Problem-17</h2>
<ul>
  <li>比较（有/无偏）重要采样，MCMC，祖先采样以及（块）Gibbs采样。其中的q(x)如何得到？如何应用基于能量的模型？</li>
  <li>如何理解MCMC是带有噪声的对能量函数进行梯度下降，能量函数的意义是什么？</li>
</ul>

<h1 id="chap-18-confronting-the-partition-function">Chap. 18 Confronting the Partition Function</h1>

<ul>
  <li>Partition functions are integral of probability</li>
  <li>The main cost of the naive MCMC algorithm is the cost of burning in the Markov chains from a random initialization at each step</li>
  <li>Using pseudolikelihood to approximate log likelihood</li>
  <li>Score matching derivave models similar to certain metrics on true model, while denoising score match considers the unavalability of true model and use a noised model instead</li>
  <li>Noise contrastive estimation is based on the idea that a good generative model should be able to distinguish data from noise</li>
  <li>Annealed importance sampling (AIS) and bridge sampling addresses the shortcomings of importance sampling</li>
</ul>

<h2 id="problem-18">Problem-18</h2>
<ul>
  <li>正相推高，负相压低数据分布概率的原理</li>
  <li>Naive MCMC，CD算法，PCD算法之间的比较</li>
  <li>伪似然与负相降低之间的关系</li>
  <li>得分匹配与平方误差的表达式较为相近，其内在是否存在关系？</li>
</ul>

<h1 id="chap-19-approximate-inference">Chap. 19 Approximate Inference</h1>
<ul>
  <li>Interaction between hidden variables make it hard to inference (conditional probability) accurately and efficiently</li>
  <li>Evidence lower bound (ELBO) helps to transform the original inference problem into a optimization problem</li>
  <li>MAP inference means choose the most likely value as the variable</li>
</ul>

<h2 id="problem-19">Problem-19</h2>
<ul>
  <li>变分推断的核心是什么？找到一个p来拟合吗？</li>
</ul>

<h1 id="chap-20-deep-generative-models">Chap. 20 Deep Generative Models</h1>
<ul>
  <li>Boltzman machines were an “connectionist” approach, and they are energy-based models</li>
  <li>Learning algorithms for Boltzmann macines are based on maximum likelihood</li>
</ul>

<h2 id="problem-20">Problem-20</h2>
<ul>
  <li>生成模型在算法中的具体应用</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/leetcode-1-to-20/" title="LeetCode #1~#20"><img src="http://localhost:4000/images/abstract-9.jpg" alt="LeetCode #1~#20"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2019-01-09T00:00:00+08:00"><a href="http://localhost:4000/leetcode-1-to-20/">January 09, 2019</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About BenSuuun">BenSuuun</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/leetcode-1-to-20/" rel="bookmark" title="LeetCode #1~#20" itemprop="url">LeetCode #1~#20</a></h1>
    
  </header>
  <div class="entry-content">
    <h2 id="1-two-sum">#1 Two Sum</h2>

<h3 id="暴力求解">暴力求解</h3>
<p>时间$O(n^2)$<br />
空间$O(1)$<br />
双层嵌套循环遍历数组，直至找到结果</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="s">"""
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
</code></pre></div></div>

<h3 id="排序后求解">排序后求解</h3>
<p>时间$O(n\log n)$<br />
空间$O(1)$<br />
选择该复杂度的排序算法，如快速排序；随后两端双指针相向遍历</p>

<h3 id="hash求解">*Hash求解</h3>
<p>时间$O(n)$<br />
空间$O(n)$<br />
将数据映射入hash表；遍历数值，并在hash表中寻找差值</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="s">"""
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """</span>
        <span class="n">hashTable</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># python中dict以hash table方法实现
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">hashTable</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">hashTable</span> <span class="ow">and</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">res</span><span class="p">]])</span>
        <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">'No solution'</span><span class="p">)</span>
        <span class="c1">#异常处理
</span></code></pre></div></div>

<h3 id="tip">Tip</h3>
<ul>
  <li>关注异常情况的处理</li>
  <li>了解语言内建数据结构的实现方法
    <ul>
      <li>python中<a href="https://mail.python.org/pipermail/python-list/2000-March/048085.html">dictionary</a>以hash table方法实现</li>
    </ul>
  </li>
</ul>

<h2 id="2-add-two-numbers">#2 Add Two Numbers</h2>

<h3 id="逐位运算">逐位运算</h3>
<p>时间$O(n)$<br />
空间$O(n)$<br />
两个链表上定义指针，逐位运算，考虑进位情况</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">addTwoNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="s">"""
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">l1</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">l2</span>
        <span class="n">lr</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">pr</span> <span class="o">=</span> <span class="n">lr</span>
        <span class="n">incre</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">p1</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">incre</span> <span class="o">+</span> <span class="n">p1</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="n">val</span>
            <span class="n">incre</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">//</span> <span class="mi">10</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span>
            <span class="n">pr</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="nb">next</span>
        <span class="k">while</span> <span class="n">p1</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">incre</span> <span class="o">+</span> <span class="n">p1</span><span class="o">.</span><span class="n">val</span>
            <span class="n">incre</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">//</span> <span class="mi">10</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span>
            <span class="n">pr</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="nb">next</span>
        <span class="k">while</span> <span class="n">p2</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">incre</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="n">val</span>
            <span class="n">incre</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">//</span> <span class="mi">10</span>
            <span class="n">tmp</span> <span class="o">=</span><span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span>
            <span class="n">pr</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="nb">next</span>
        <span class="k">if</span> <span class="n">incre</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#当最后有进位时
</span>            <span class="n">pr</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">incre</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lr</span><span class="o">.</span><span class="nb">next</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="逐位运算-简化">*逐位运算-简化</h3>
<p>时间$O(n)$<br />
空间$O(n)$<br />
利用bool()的性质，仅在0、None或空集情况下为False</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">addTwoNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="s">"""
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """</span>
        <span class="n">lr</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">pr</span> <span class="o">=</span> <span class="n">lr</span>
        <span class="n">incre</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">incre</span> <span class="ow">or</span> <span class="n">l1</span> <span class="ow">or</span> <span class="n">l2</span><span class="p">:</span>
            <span class="c1">#bool性质
</span>            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">l1</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">+=</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">l2</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">+=</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">incre</span>
            <span class="n">incre</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">//</span> <span class="mi">10</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span>
            <span class="n">pr</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lr</span><span class="o">.</span><span class="nb">next</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="tip-1">Tip</h3>
<ul>
  <li>类之间的<a href="https://www.cnblogs.com/jiangzhaowei/p/5740913.html">赋值</a>与指针引用的关系
    <ul>
      <li>函数中，不可变值与可变值传递有区别，都可认为是“局部变量”即传入变量的指针不变，但后者传递的指针引用可在函数中修改值</li>
      <li>python的变量都可看作是指针</li>
    </ul>
  </li>
  <li>考虑边界情况</li>
</ul>

<h2 id="3-longest-substring-without-repeating-characters">#3 Longest Substring Without Repeating Characters</h2>

<h3 id="朴素求解">朴素求解</h3>
<p>设将第i位字符作为最后一位的最长符合要求子串长度为l(i)，其包含字符集合为s[i-l(i): i+1]。当遇到第i+1位字符时，为了计算l(i+1)，若第i+1位字符出现在上述集合，需要提取其位置，并重新计算l(i+1)；若未出现，则结果为l(i)+1。<br />
时间优化方面，关键在判断字符是否出现在集合以及其相应的位置。朴素求解使用基本的数据遍历的方式。<br />
时间$O(n^2)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="s">"""
        :type s: str
        :rtype: int
        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#边界条件
</span>            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="hash求解-1">*Hash求解</h3>
<p>思路类似朴素求解，额外维护一张HashTable，记录每个字符最近出现的位置<br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="s">"""
        :type s: str
        :rtype: int
        """</span>
        <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">pos</span> <span class="ow">and</span> <span class="n">pos</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="c1">#and和or都是short-circuitlogic
</span>                <span class="n">start</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxLen</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">maxLen</span>
</code></pre></div></div>

<h3 id="tip-2">Tip</h3>
<ul>
  <li>考虑边界情况，空集</li>
  <li>在数组切片时，把握位置与长度</li>
</ul>

<h2 id="4-median-of-two-sorted-arrays">#4 Median of Two Sorted Arrays</h2>

<h3 id="递归求解">递归求解</h3>
<p>将问题转换成给定两组排好序的数据，寻找第i大的值。取两个数组里面的中间位置数，进行比较，能够得到一些位置的数在所有数据中的排名情况，例如图4.1。</p>
<figure>
    <img src="/images/LeetCode/LeetCode4.1.jpg" alt="" />
    <figcaption>图4.1</figcaption>
</figure>
<p>切除不可能符合要求的数，缩小两个数列，递归求解.<br />
时间$O(\log n)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findMedianSortedArrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">):</span>
        <span class="s">"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">t1</span> <span class="o">&gt;</span> <span class="n">h1</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t2</span> <span class="o">&gt;</span> <span class="n">h2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">h1</span> <span class="o">+</span> <span class="n">t1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">h2</span> <span class="o">+</span> <span class="n">t2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">midValue1</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">m1</span><span class="p">]</span>
            <span class="n">midValue2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">m2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">midValue1</span> <span class="o">&lt;=</span> <span class="n">midValue2</span><span class="p">:</span>
                <span class="n">remainL</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">remainL</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">remainL</span><span class="p">,</span> <span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">remainR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">remainR</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">remainR</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">m2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">remainL</span><span class="p">)</span>
                <span class="n">h1</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">-</span> <span class="n">remainL</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">remainR</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remainL</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">remainL</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">remainL</span><span class="p">,</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">remainR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">remainR</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">remainR</span><span class="p">,</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">m1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="p">(</span><span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">remainL</span><span class="p">)</span>
                <span class="n">h2</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">remainL</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">remainR</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">t1</span> <span class="o">==</span> <span class="n">h1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">numL</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">h2</span> <span class="o">+</span> <span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">t2</span><span class="o">==</span> <span class="n">h2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">numL</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">h1</span> <span class="o">+</span> <span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">t1</span> <span class="o">&gt;</span> <span class="n">h1</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t2</span> <span class="o">&gt;</span> <span class="n">h2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">h1</span> <span class="o">+</span> <span class="n">t1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">h2</span> <span class="o">+</span> <span class="n">t2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">midValue1</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">m1</span><span class="p">]</span>
            <span class="n">midValue2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">m2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">midValue1</span> <span class="o">&lt;=</span> <span class="n">midValue2</span><span class="p">:</span>
                <span class="n">remainL</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">remainL</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">remainL</span><span class="p">,</span> <span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">remainR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">remainR</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">remainR</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">m2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">remainL</span><span class="p">)</span>
                <span class="n">h1</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">-</span> <span class="n">remainL</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">remainR</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remainL</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">remainL</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">remainL</span><span class="p">,</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">remainR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">remainR</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">remainR</span><span class="p">,</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">m1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="p">(</span><span class="n">m2</span> <span class="o">-</span> <span class="n">h2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">remainL</span><span class="p">)</span>
                <span class="n">h2</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">remainL</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">remainR</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">t1</span> <span class="o">==</span> <span class="n">h1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">numR</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">h2</span> <span class="o">+</span> <span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">t2</span> <span class="o">==</span> <span class="n">h2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">numR</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">h1</span> <span class="o">+</span> <span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">numL</span> <span class="o">+</span> <span class="n">numR</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div>

<h3 id="tip-3">Tip</h3>
<ul>
  <li>对变量更新时，检查其是否会影响其他变量，需要合理安排次序甚至加入临时变量</li>
  <li>数学库的函数需要加载</li>
</ul>

<h2 id="5-longest-palindromic-substring">#5 Longest Palindromic Substring</h2>

<h3 id="中心搜索">中心搜索</h3>

<p>搜索回文子串的中心位置，包括两类，一是字母本身作为中心，二是两个字母间隙作为中心。<br />
得到中心后，向两边拓展，得到最长的串。并在后续搜索中，进行适当的剪枝。<br />
时间$O(n^2)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestPalindrome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="s">"""
        :type s: str
        :rtype: str
        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">""</span>
        <span class="n">lenMax</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">strMax</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">center</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">center</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">center</span> <span class="o">+</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">s</span><span class="p">[</span><span class="n">center</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">center</span> <span class="o">+</span> <span class="n">l</span><span class="p">]:</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">lenMax</span><span class="p">:</span>
                <span class="n">lenMax</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">strMax</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">center</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">center</span><span class="o">+</span><span class="n">l</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">center</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lenMax</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">lenMax</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">center</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">center</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">center</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">center</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">s</span><span class="p">[</span><span class="n">center</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">center</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">l</span><span class="p">]:</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">lenMax</span><span class="p">:</span>
                <span class="n">lenMax</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">2</span>
                <span class="n">strMax</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">center</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">center</span><span class="o">+</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">strMax</span>
</code></pre></div></div>

<h3 id="tip-4">Tip</h3>
<ul>
  <li>尽可能剪枝降低时间复杂度</li>
</ul>

<h2 id="6-zigzag-conversion">#6 ZigZag Conversion</h2>

<h3 id="数学规律">数学规律</h3>
<p>发现经过变换后，每行的两个数下标依次增加为$2(numRows - i) - 2$与$2i$，其中$i$为行数。<br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">numRows</span><span class="p">):</span>
        <span class="s">"""
        :type s: str
        :type numRows: int
        :rtype: str
        """</span>
        <span class="n">res</span> <span class="o">=</span> <span class="s">''</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">if</span> <span class="n">numRows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numRows</span><span class="p">):</span>
            <span class="n">delta1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">numRows</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">delta2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">cur</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cur</span> <span class="o">+</span> <span class="n">delta1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">delta1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cur</span> <span class="o">+=</span> <span class="n">delta1</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">cur</span> <span class="o">+</span> <span class="n">delta2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">delta2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cur</span> <span class="o">+=</span> <span class="n">delta2</span>
                        <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h3 id="tip-5">Tip</h3>
<ul>
  <li>注意边界情况，不同输入变量都得考虑</li>
  <li>布尔类型注意大小写True与False</li>
</ul>

<h2 id="7-reverse-integer">#7 Reverse Integer</h2>

<h3 id="逐位累计">逐位累计</h3>
<p>输入的数字模10可得到末尾数字，记录，随后再整除10可略去末尾数字<br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s">"""
        :type x: int
        :rtype: int
        """</span>
        <span class="n">upLim</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">downLim</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">upLim</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">downLim</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">rev</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="n">rev</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">10</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">//</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span><span class="p">:</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="o">-</span><span class="n">rev</span>
        <span class="k">if</span> <span class="n">rev</span> <span class="o">&gt;</span> <span class="n">upLim</span> <span class="ow">or</span> <span class="n">rev</span> <span class="o">&lt;</span> <span class="n">downLim</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">rev</span>
</code></pre></div></div>

<h3 id="tip-6">Tip</h3>
<ul>
  <li>给定限制条件，同时需要判断输入限制和输出限制</li>
  <li>取反为not</li>
</ul>

<h2 id="8-string-to-integer-atoi">#8 String to Integer (atoi)</h2>

<h3 id="逐位判断">逐位判断</h3>
<p>依据题目给定条件依次逐位判断，利用ord()取字符的ASCII码 <br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">myAtoi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="s">"""
        :type str: str
        :rtype: int
        """</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="o">==</span> <span class="s">' '</span><span class="p">:</span>
            <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">pointer</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="o">==</span> <span class="s">'+'</span><span class="p">:</span>
            <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">str</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="o">==</span> <span class="s">'-'</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">str</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">INT_MAX</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">INT_MIN</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="n">pointer</span><span class="p">])</span> <span class="o">-</span> <span class="mi">48</span>
            <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">pos</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">num</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num</span>
</code></pre></div></div>

<h3 id="tip-7">Tip</h3>
<ul>
  <li>边界情况的处理</li>
</ul>

<h2 id="9-palindrome-number">#9 Palindrome Number</h2>

<h3 id="逐位翻转">逐位翻转</h3>
<p>通过不断对10取余，整除10逐位得到其翻转的数字，与原始数字比较判断是否回文<br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s">"""
        :type x: int
        :rtype: bool
        """</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">inputNum</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">revNum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">inputNum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">revNum</span> <span class="o">=</span> <span class="n">revNum</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">inputNum</span> <span class="o">%</span> <span class="mi">10</span>
            <span class="n">inputNum</span> <span class="o">=</span> <span class="n">inputNum</span> <span class="o">//</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">revNum</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h3 id="tip-8">Tip</h3>
<ul>
  <li>关注题设限制要求</li>
</ul>

<h2 id="10-regular-expression-matching">#10 Regular Expression Matching</h2>

<h3 id="递归逐位匹配">递归逐位匹配</h3>
<p>从字符串头开始，匹配各位字符，出现.和*时遍历各种可能性<br />
时间N/A~$O(n!)$<br />
空间N/A~$O(n!)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'*'</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'.'</span><span class="p">:</span>
                <span class="n">pointerS</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">pointerS</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isMatch</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">pointerS</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:]):</span>
                        <span class="k">return</span> <span class="bp">True</span>
                    <span class="n">pointerS</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isMatch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:]):</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pointerS</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">pointerS</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">pointerS</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isMatch</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">pointerS</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:]):</span>
                        <span class="k">return</span> <span class="bp">True</span>
                    <span class="n">pointerS</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isMatch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:]):</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'.'</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isMatch</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isMatch</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                        <span class="k">return</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h3 id="动态规划">*动态规划</h3>
<p>发现存在重复求解的函数请求，可以将其保存，推导出显式公式，从而降低复杂度<br />
时间$O(n^2)$<br />
空间$O(n^2)$</p>

<h3 id="tip-9">Tip</h3>
<ul>
  <li>一些简便写法
    <ul>
      <li>if text: 等同于 if len(text) &gt; 0</li>
      <li>bool(text)可直接得到是否为空字符串</li>
    </ul>
  </li>
  <li>在进行递归时，考虑特定的循环是否有必要</li>
  <li>避免递归重复求解，使用DP来存储结果降低时间复杂度</li>
</ul>

<h2 id="11-container-with-most-water">#11 Container With Most Water</h2>

<h3 id="暴力求解-1">暴力求解</h3>
<p>计算柱子两两构成的面积，比较大小<br />
时间$O(n^2)$<br />
空间$O(1)$</p>

<h3 id="搜索注水高度">搜索注水高度</h3>
<p>对柱子高度排序，依次降低目标注水高度，维护最边两侧的柱子坐标，面积即可通过柱子坐标差乘注水高度得到<br />
时间$O(n\log n)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">sortedHeightLoc</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">height</span><span class="p">),</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">left</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sortedHeightLoc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">sortedHeightLoc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sortedHeightLoc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">sortedHeightLoc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">maxArea</span> <span class="o">=</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">*</span> <span class="n">sortedHeightLoc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">sortedHeightLoc</span><span class="p">[</span><span class="n">pointer</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">sortedHeightLoc</span><span class="p">[</span><span class="n">pointer</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">maxArea</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxArea</span><span class="p">,</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">*</span> <span class="n">sortedHeightLoc</span><span class="p">[</span><span class="n">pointer</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">maxArea</span>
</code></pre></div></div>

<h3 id="两侧逼近">*两侧逼近</h3>
<p>两侧维护指针作为柱子两侧，初始化是最两侧的柱子；随后，较矮的柱子指针不断内移，存在增加面积的可能性<br />
时间$O(n)$<br />
空间$O(1)$</p>

<h3 id="tip-10">Tip</h3>
<ul>
  <li>在设定目标复杂度的算法后，考虑常见的遍历、运算等操作和特定的小技巧，如双指针维护等</li>
  <li>排序中enumerate和lambda返回下标的用法</li>
</ul>

<h2 id="12-integer-to-roman">#12 Integer to Roman</h2>

<h3 id="依次取模">依次取模</h3>
<p>存储每个可能的字符及其值，随后不断取模并记录可能使用的字符个数，将字符组合起来得到结果<br />
时间$O(1)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">intToRoman</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="s">''</span>
        <span class="n">valueSymbol</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1000</span><span class="p">,</span> <span class="s">'M'</span><span class="p">),</span> <span class="p">(</span><span class="mi">900</span><span class="p">,</span> <span class="s">'CM'</span><span class="p">),</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="s">'D'</span><span class="p">),</span> <span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="s">'CD'</span><span class="p">),</span> \
                      <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s">'C'</span><span class="p">),</span> <span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="s">'XC'</span><span class="p">),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="s">'L'</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="s">'XL'</span><span class="p">),</span> \
                      <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">'X'</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="s">'IX'</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">'V'</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">'IV'</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'I'</span><span class="p">)]</span>
        <span class="n">valueSymbolDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">valueSymbol</span><span class="p">)</span>
        <span class="n">valueList</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">valueSymbolDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">valueList</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="n">valueSymbolDict</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">num</span> <span class="o">//</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<h3 id="tip-11">Tip</h3>
<ul>
  <li>寻找数字构成规律</li>
</ul>

<h2 id="13-roman-to-integer">#13 Roman to Integer</h2>

<h3 id="按位判断值正负">按位判断值正负</h3>
<p>若当前字符的值小于下一个字符的值，则减去该值；否则加上该值<br />
时间$O(1)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">romanToInt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">symbolValue</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'I'</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">'V'</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="s">'X'</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="s">'L'</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> \
                      <span class="p">(</span><span class="s">'C'</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="s">'D'</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="p">(</span><span class="s">'M'</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)]</span>
        <span class="n">symbolValueDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">symbolValue</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">preValue</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">curValue</span> <span class="o">=</span> <span class="n">symbolValueDict</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">preValue</span> <span class="o">&lt;</span> <span class="n">curValue</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">-=</span> <span class="n">preValue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">+=</span> <span class="n">preValue</span>
            <span class="n">preValue</span> <span class="o">=</span> <span class="n">curValue</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="n">preValue</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<h3 id="tip-12">Tip</h3>
<ul>
  <li>从双向转化中寻找规律</li>
</ul>

<h2 id="14-longest-common-prefix">#14 Longest Common Prefix</h2>

<h3 id="按位判断">按位判断</h3>
<p>依次遍历各位，直到出现不同字符<br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestCommonPrefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">""</span>
        <span class="n">lenMax</span> <span class="o">=</span> <span class="mf">1e9</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="n">lenMax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lenMax</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pointer</span> <span class="o">==</span> <span class="n">lenMax</span><span class="p">:</span>
                <span class="n">pointer</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">break</span>
            <span class="n">char</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">pointer</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">pointer</span><span class="p">]</span> <span class="o">!=</span> <span class="n">char</span><span class="p">:</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
                <span class="n">pointer</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">break</span>
            <span class="n">pointer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">pointer</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="tip-13">Tip</h3>
<ul>
  <li>注意边界情况，如空集、空字符串等，易出现访问错误</li>
</ul>

<h2 id="15-3sum">#15 3Sum</h2>

<h3 id="列举元素重复次数">列举元素重复次数</h3>
<p>分三种情况依次寻找可能的组合。1.三个元素均不重复，通过其大小关系限制重复组合。2.有两个元素重复，通过出现次数统计限制重复组合。3.三个元素均重复，仅有可能为3个0<br />
时间$O(n^2)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">collections</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">numDict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">numSort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">numDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numSort</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">numSort</span><span class="p">)):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">numSort</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">numSort</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">numDict</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numDict</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">numDict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="ow">in</span> <span class="n">numDict</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">numDict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<h3 id="tip-14">Tip</h3>
<ul>
  <li>多维数组输出时注意其结构</li>
</ul>

<h2 id="16-3sum-closest">#16 3Sum Closest</h2>

<h3 id="穷举">穷举</h3>
<p>次序挑选可能的三个元素，计算其和与目标的距离，保存其中的最优值<br />
时间$O(n^3)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">threeSumClosest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">bestSol</span> <span class="o">=</span> <span class="mf">1e9</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                    <span class="n">sum3</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sum3</span> <span class="o">-</span> <span class="n">target</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bestSol</span> <span class="o">-</span> <span class="n">target</span><span class="p">):</span>
                        <span class="n">bestSol</span> <span class="o">=</span> <span class="n">sum3</span>
        <span class="k">return</span> <span class="n">bestSol</span>
</code></pre></div></div>
<h3 id="排序后二分">排序后二分</h3>
<p>将数据排序，随后挑选可能的前两个元素，二分查找最接近的值，需要限定位置关系来避免重复<br />
时间$O(n^2\log n)$<br />
空间$O(1)$</p>

<h3 id="穷举预先剪枝">*穷举预先剪枝</h3>
<p>将数据排序，确定第一个元素后，使用两指针来挑选元素。通过比较当前的和与目标值，确定左指针右移还是右指针左移。及时保存最优值<br />
时间$O(n^2)$<br />
空间$O(1)$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># @return an integer
</span>    <span class="k">def</span> <span class="nf">threeSumClosest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">num</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="nb">sum</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">sum</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span> <span class="o">-</span> <span class="n">target</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">result</span> <span class="o">-</span> <span class="n">target</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">sum</span>
                <span class="k">if</span> <span class="nb">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="nb">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h3 id="tip-15">Tip</h3>
<ul>
  <li>穷举时考虑剪枝的可能性，提前降低复杂度</li>
  <li>双指针逼近的这一系列策略需要内化</li>
</ul>

<h2 id="17-letter-combinations-of-a-phone-number">#17 Letter Combinations of a Phone Number</h2>

<h3 id="逐位组合">逐位组合</h3>
<p>存储每个数字可能代表的字符，随后依次扩充<br />
时间$O(3^n)$<br />
空间$O(3^n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">letterCombinations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digits</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">letterDict</span> <span class="o">=</span> <span class="p">{</span><span class="s">'2'</span><span class="p">:</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">],</span> <span class="s">'3'</span><span class="p">:</span> <span class="p">[</span><span class="s">'d'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">,</span> <span class="s">'f'</span><span class="p">],</span> \
                      <span class="s">'4'</span><span class="p">:</span> <span class="p">[</span><span class="s">'g'</span><span class="p">,</span> <span class="s">'h'</span><span class="p">,</span> <span class="s">'i'</span><span class="p">],</span> <span class="s">'5'</span><span class="p">:</span> <span class="p">[</span><span class="s">'j'</span><span class="p">,</span> <span class="s">'k'</span><span class="p">,</span> <span class="s">'l'</span><span class="p">],</span> \
                      <span class="s">'6'</span><span class="p">:</span> <span class="p">[</span><span class="s">'m'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> <span class="s">'o'</span><span class="p">],</span> <span class="s">'7'</span><span class="p">:</span> <span class="p">[</span><span class="s">'p'</span><span class="p">,</span> <span class="s">'q'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="s">'s'</span><span class="p">],</span> \
                      <span class="s">'8'</span><span class="p">:</span> <span class="p">[</span><span class="s">'t'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'v'</span><span class="p">],</span> <span class="s">'9'</span><span class="p">:</span> <span class="p">[</span><span class="s">'w'</span><span class="p">,</span> <span class="s">'x'</span><span class="p">,</span> <span class="s">'y'</span><span class="p">,</span> <span class="s">'z'</span><span class="p">]}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">digits</span><span class="p">:</span>
            <span class="n">temOutput</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">letterDict</span><span class="p">[</span><span class="n">num</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
                    <span class="n">temOutput</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">code</span><span class="o">+</span><span class="n">char</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">temOutput</span><span class="p">[:]</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<h3 id="tip-16">Tip</h3>
<ul>
  <li>输入为空时，需要检验已有算法能否处理</li>
  <li>换行符\的放置</li>
</ul>

<h2 id="18-4sum">#18 4Sum</h2>

<h3 id="迭代求解">迭代求解</h3>
<p>先对元素进行排序。核心是快速实现2-Sum，使用两端指针不断逼近，重复元素的限制条件是左侧指针需指向第一个、右侧指针需指向最后一个。3-Sum相当于选择一个元素后，在其右侧的元素寻找2-Sum，同样限制条件是需要指向重复元素的第一个。4-Sum类似，选择一个元素，在右侧寻找3-Sum，同样限制上条件。<br />
时间$O(n^3)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fourSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">numSort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numSort</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">numSort</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">p4</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">numSort</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">p3</span> <span class="o">&lt;</span> <span class="n">p4</span><span class="p">:</span>
                <span class="n">sum4</span> <span class="o">=</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">+</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">+</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span> <span class="o">+</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p4</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sum4</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">p4</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">p3</span> <span class="o">&lt;</span> <span class="n">p4</span> <span class="ow">and</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p4</span><span class="p">]</span> <span class="o">==</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p4</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">p4</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">sum4</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">p3</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">p3</span> <span class="o">&lt;</span> <span class="n">p4</span> <span class="ow">and</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span> <span class="o">==</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p3</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">p3</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">sum4</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">numSort</span><span class="p">[</span><span class="n">p1</span><span class="p">],</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p2</span><span class="p">],</span> \
                                   <span class="n">numSort</span><span class="p">[</span><span class="n">p3</span><span class="p">],</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p4</span><span class="p">]])</span>
                    <span class="n">p3</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">p3</span> <span class="o">&lt;</span> <span class="n">p4</span> <span class="ow">and</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span> <span class="o">==</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p3</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">p3</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">p4</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">p3</span> <span class="o">&lt;</span> <span class="n">p4</span> <span class="ow">and</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p4</span><span class="p">]</span> <span class="o">==</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p4</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">p4</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">numSort</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p2</span><span class="p">]:</span>
                <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">p2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">numSort</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">numSort</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">numSort</span><span class="p">[</span><span class="n">p1</span><span class="p">]:</span>
                    <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<h3 id="tip-17">Tip</h3>
<ul>
  <li>从递归角度考虑问题，在指针变化时可自行模拟推导确定细节条件</li>
</ul>

<h2 id="19-remove-nth-node-from-end-of-list">#19 Remove Nth Node From End of List</h2>

<h3 id="双指针访问">双指针访问</h3>
<p>先访问n个节点，随后新添一个指针，与原指针以相同步调访问下去。当原指针访问到末尾时，新指针所指示位置后一节点应被删去。<br />
时间$O(n)$<br />
空间$O(1)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">lead</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lead</span> <span class="o">=</span> <span class="n">lead</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">choose</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lead</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="nb">next</span>
            <span class="k">return</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">lead</span><span class="o">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">lead</span> <span class="o">=</span> <span class="n">lead</span><span class="o">.</span><span class="nb">next</span>
            <span class="n">choose</span> <span class="o">=</span> <span class="n">choose</span><span class="o">.</span><span class="nb">next</span>
        <span class="n">choose</span><span class="o">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">choose</span><span class="o">.</span><span class="nb">next</span><span class="o">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">head</span>
</code></pre></div></div>

<h3 id="tip-18">Tip</h3>
<ul>
  <li>注意边界条件，删除头元素需特殊处理</li>
  <li>函数传入的元素是一个类，迭代访问下一个元素不会更改原本的值</li>
</ul>

<h2 id="20-valid-parentheses">#20 Valid Parentheses</h2>

<h3 id="栈结构">栈结构</h3>
<p>字符若为左侧括号，入栈；否则，从栈弹出一字符，比较是否合法。<br />
时间$O(n)$<br />
空间$O(n)$</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s">'('</span><span class="p">,</span> <span class="s">'{'</span><span class="p">,</span> <span class="s">'['</span><span class="p">])</span>
        <span class="n">right</span> <span class="o">=</span> <span class="p">{</span><span class="s">')'</span><span class="p">:</span> <span class="s">'('</span><span class="p">,</span> <span class="s">'}'</span><span class="p">:</span> <span class="s">'{'</span><span class="p">,</span> <span class="s">']'</span><span class="p">:</span> <span class="s">'['</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">char</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="n">charPop</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">right</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">!=</span> <span class="n">charPop</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h3 id="tip-19">Tip</h3>
<ul>
  <li>栈可以用内置的List实现，队列用collections.deque</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
      <div class="entry-image-index">
        <a href="http://localhost:4000/notes-statistical-natural-language-process/" title="Notes-Statistical Natural Language Process"><img src="http://localhost:4000/images/abstract-3.jpg" alt="Notes-Statistical Natural Language Process"></a>
      </div><!-- /.entry-image -->
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2019-01-08T00:00:00+08:00"><a href="http://localhost:4000/notes-statistical-natural-language-process/">January 08, 2019</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About BenSuuun">BenSuuun</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/notes-statistical-natural-language-process/" rel="bookmark" title="Notes-Statistical Natural Language Process" itemprop="url">Notes-Statistical Natural Language Process</a></h1>
    
  </header>
  <div class="entry-content">
    <h2 id="notes-of-统计自然语言处理-by-宗成庆">Notes of 《统计自然语言处理》 by 宗成庆</h2>

<h2 id="第1章-绪论">第1章 绪论</h2>
<ul>
  <li>计算语言学包括语音与语义</li>
  <li>形态、语法、语义、语用等层次，核心问题都是歧义消解
    <ul>
      <li>歧义组合可由开塔兰数（Catalan numbers）计算</li>
      <li>$C_n = {2n \choose n}\frac{1}{n+1}$ 其中n为介词短语数</li>
    </ul>
  </li>
  <li>自然语言处理的研究方法有理性主义和经验主义</li>
  <li>许多自然语言处理的任务可以由<strong>噪声信道模型</strong>实现和完成</li>
</ul>

<h2 id="第2章-预备知识">第2章 预备知识</h2>
<ul>
  <li>全概率公式 $P(A) = \sum_iP(A|B_i)P(B_i)$</li>
  <li>通常假设一个句子出现独立于它之前的语句，句子概率分布近似符合二项式分布</li>
  <li>[熵]定义$H(X) = -\sum_{x\in R}p(x)log_2p(x)$
    <ul>
      <li>熵最大时，随机变量最不确定</li>
    </ul>
  </li>
  <li>[熵连锁规则]$H(X_1,…, X_n)$ $= H(X_1) + …+H(X_n|X_1, …,X_{n-1})$ 这里涉及到联合熵与条件熵</li>
  <li>[互信息]$I(X;Y) = H(X) - H(X|Y)$知道了Y的信息后，X不确定性的减少量
    <ul>
      <li>$I(X;X) = 0$ 因而熵又称为自信息</li>
    </ul>
  </li>
  <li>[相对熵]$D(p||q) = \sum_{x\in X}p(x)log\frac{p(x)}{q(x)}$ 两个概率分布相对差距的测度
    <ul>
      <li>互信息是衡量联合分布与独立性的相对熵</li>
    </ul>
  </li>
  <li>[交叉熵]$H(X,q) = H(X) + D(p||q)$ p是真实分布，q是近似分布，X是p的随机变量
    <ul>
      <li>困惑度常作为模型质量评估指标</li>
    </ul>
  </li>
  <li>线性分类器存在对偶形式</li>
</ul>

<h2 id="第3章-形式语言与自动机">第3章 形式语言与自动机</h2>
<ul>
  <li>[闭包]$V^*=V^++{\epsilon} = V^1\cup V^2\cup …+V^0$</li>
  <li>[规范推导]又称最右推导，每次只改写最右边的非终结符</li>
  <li>[文法分类]正则文法、上下文无关文法、上下文相关文法和无约束文法</li>
  <li>[派生树]CFG（Context-free Grammer）可表示，也称语法树、分析树、推导树</li>
  <li>[自动机]Automata，包含状态、转移方程等的集合变换方式
    <ul>
      <li>正则文法 - 有限自动机</li>
      <li>上下文无关文法 - 下推自动机</li>
      <li>上下文相关文法 - 线性界限自动机（单带图灵机）</li>
      <li>无约束文法 - 图灵机</li>
    </ul>
  </li>
  <li>[有限状态机]路径从初始状态到终止状态经过的所有弧上的字母连接起来构成一个字符串</li>
  <li>[有限状态转换机]与有效状态机区别在于完成状态转移的同时产生一个输出</li>
</ul>

<h2 id="第4章-语料库与语言知识库">第4章 语料库与语言知识库</h2>
<ul>
  <li>[语料库]分几个层次，除了本身包含的词汇外，还会有句法、深层语法等内容，也可以是多媒体的形式</li>
  <li>[语言知识库]包括语料库，分为显性结构化知识和隐性文本信息两类</li>
  <li>[本体论]核心概念是知识共享，内容包括主要概念以及它们之间的关系
    <ul>
      <li>本体可分为上位本体、领域本体以及面向应用的本体三个层次</li>
    </ul>
  </li>
</ul>

<h2 id="第5章-语言模型">第5章 语言模型</h2>
<ul>
  <li>[n元语法]将“历史”限定在前n个时间段，n=3即三元文法模型称为二阶马尔可夫链
    <ul>
      <li>$w_i^j$指第i位到第j位的“语法”,是j-i+1阶。</li>
    </ul>
  </li>
  <li>[交叉熵]利用预测和压缩的关系计算：$H_p(T) = -\frac{1}{W_T}log_2p(T)$
    <ul>
      <li>$p(T)$为文本T的概率，$W_T$是以词为单位度量的文本T的长度</li>
      <li>含义：利用与模型$p(w_i|w^{i-1}_{i-n+1})$有关的压缩算法对数据集合中的$W_T$个词进行编码，每一个编码所需要的平均比特位数</li>
    </ul>
  </li>
  <li>[平滑]解决零概率问题，一些未出现在语料中的零概率情形实则并非零概率
    <ul>
      <li>Good-Turing估计法是很多平滑技术的核心
        <ul>
          <li>$r^*=(r+1)\frac{n_{r+1}}{n_r}$</li>
          <li>$p_r = \frac{r^*}N$, $N = \sum^\infty _{r=0}n_rr^*=\sum^\infty _{r=1}n_rr$</li>
        </ul>
      </li>
      <li>Katz对于非零小计数值的语法减值，折扣率$d_r\approx \frac{r^*}r$</li>
      <li>Jelinek-Mercer 用低阶模型差值预测高阶模型
        <ul>
          <li>Witten-Bell是一个实例</li>
          <li>绝对减值法类似差值，不过直接减去固定值来建立高阶分布</li>
          <li>Knesey-Ney是拓展的绝对减值法，使用一元文法的概率应与它前面的不同单词数目成比例</li>
        </ul>
      </li>
      <li>平滑算法分为后备模型和差值模型</li>
    </ul>
  </li>
  <li>平滑方法中，Knesey-Ney及其变种表现最好</li>
  <li>[自适应模型]语言模型理论基础较为完善，但需要考虑跨领域的问题
    <ul>
      <li>基于缓存模型假设近期出现的词在后续出现可能性大</li>
      <li>基于混合模型先对训练语料聚类，对不同领域分别训练模型</li>
    </ul>
  </li>
</ul>

<h2 id="第6章-概率图模型">第6章 概率图模型</h2>
<ul>
  <li>[概率图]基于图的方法表示概率分布，结点表示变量，边表示变量之间的概率关系</li>
  <li>[生成式模型]又称产生式模型，假设状态序列y决定观测序列x，是所有变量的全概率模型</li>
  <li>[区分式模型]又称判别式模型，假设观测序列x决定状态序列y，是传统的模式分类思想，通常是有监督学习</li>
  <li>[贝叶斯网络]两个节点有联结表示这两个随机变量在任何情况下都不存在条件独立
    <ul>
      <li>构造包括表示、推断、学习等步骤</li>
    </ul>
  </li>
  <li>[马尔可夫模型]描述当前状态与历史n阶状态的转移关系</li>
  <li>[隐马尔可夫模型]两个随机过程，状态及其转移未知，但状态的输出可观测
    <ul>
      <li>基本问题包括估计问题、序列问题和训练问题</li>
      <li>估计/解码问题求解给定模型下，特定观测序列的概率
        <ul>
          <li>动态规划求解，仅与上一时刻的状态相关，即前向算法</li>
          <li>同样，也可以使用后向算法来计算，也可结合前向后向同时计算</li>
        </ul>
      </li>
      <li>序列问题求解给定模型和观测结果，最优状态序列
        <ul>
          <li>Viterbi算法可求解，利用动态规划，维特比变量类似前向变量，存在递归关系</li>
        </ul>
      </li>
      <li>训练问题/参数估计问题，给定观察序列，调节参数使其概率最大
        <ul>
          <li>利用EM算法直接模拟，得到隐变量的期望值，代替待估计值</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>[层次化的隐马尔可夫模型]每个状态本身就是一个独立的HHMM，一个状态产生一个观察序列而非观察符号</li>
  <li>[马尔可夫网络]类似贝叶斯网络，能额外表示循环依赖，但无法表示推导关系，是无向图模型</li>
  <li>[最大熵原理]在已知部分信息的前提下，关于未知分布最合理的推断应该是符合已知信息最不确定或最大随机的推断，即使熵值最大
    <ul>
      <li>可用通用迭代算法GIS训练参数，选取有效的特征$f_i$ 及其权重$\lambda_i$</li>
    </ul>
  </li>
  <li>[最大熵马尔可夫模型]结合隐马尔可夫链和最大熵模型，又称为条件马尔可夫模型
    <ul>
      <li>MEMM是有向图和无向图的混合模型，主体仍然是有向图。</li>
      <li>相比HMM，优点在于可任意选择特征</li>
    </ul>
  </li>
  <li>[条件随机场]通过定义条件概率而非联合概率描述模型。CRF可看做是一个无向图模型或马尔可夫随机场</li>
</ul>

<h2 id="第7章-自动分词命名实体识别与词性标注">第7章 自动分词、命名实体识别与词性标注</h2>
<ul>
  <li>[自动分词]针对汉语等孤立语、黏着语区分词，主要困难在于分词规范、歧义切分和未登录词的识别
    <ul>
      <li>分词规范指对于词的抽象定义与具体界定没有得到统一</li>
      <li>歧义切分包括交集型切分歧义与组合型切分歧义</li>
      <li>未登录词又称生词
        <ul>
          <li>大规模真实文本中，未登录词对于分词精度的影响远远超过了歧义切分</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>[汉语分词]先使用切分算法进行粗分，再进行歧义排除和未登录词识别
    <ul>
      <li>[N-最短路径]构造词语切分有向无环图，每个词对应一条有向边</li>
      <li>[由字构词]转化为序列标注问题</li>
      <li>[词感知机]直接使用词相关的特征，而非字相关特征</li>
      <li>基于词的生成式模型对集内词处理性能较好，基于字的区分时模型对集外词的处理更鲁棒</li>
    </ul>
  </li>
  <li>［命名实体］实体概念的引用有三种形式，命名性指称、名词性指称、代词性指称
    <ul>
      <li>［基于CRF］将命名实体识别看作是序列标注问题</li>
      <li>实体识别的内容主要包括人名、地名以及机构名</li>
      <li>均为试图充分发现和利用实体所在的上下文特征和实体的内部特征，仅特征的颗粒度有大小</li>
    </ul>
  </li>
  <li>［词性标注］判定句子中每个词的语法范畴，确定其词性并加以标注
    <ul>
      <li>同分词一样，是中文信息处理的重要基础性问题</li>
      <li>基于统计：HMM模型参数估计，结合数据平滑方法</li>
      <li>基于规则：按兼类词搭配关系和上下文语境建造消歧规则，可应用机器学习方法</li>
    </ul>
  </li>
  <li>［词性标注的检验］词性标注一致性指在相同的语境下对同一词标注相同的词性</li>
  <li>汉语分词研究的总体水平，F1值已经达到95%</li>
</ul>

<h2 id="第8章-句法分析">第8章 句法分析</h2>
<ul>
  <li>句法分析分为句法结构分析和依存关系分析两种</li>
  <li>［句法结构分析］使用句法结构分析器得到合乎语法的句子的树状数据句法结构
    <ul>
      <li>句法结构歧义的识别和消解是面临的主要困难</li>
      <li>一部分是形式化的规则库和词典构成举法分析的知识库；另一部分是分析算法的设计</li>
      <li>［语法形式化］目前通常采用上下文无关文法（CFG）和基于约束的文法</li>
      <li>［基于规则］通常有自顶向下、自底向上、两者结合的分析方法</li>
      <li>［基于统计］通常语法驱动，由生成语法定义被分析语言及其分析出的类</li>
    </ul>
  </li>
  <li>［PCFG］是CFG的扩展，引入概率，具有位置不变性、上下文无关性和祖先无关性的特征
    <ul>
      <li>计算结构概率，利用DP的内向外向算法</li>
      <li>选择最佳结构，利用Viterbi算法结合DP</li>
      <li>概率参数估计，采用EM迭代算法</li>
    </ul>
  </li>
  <li>［词汇化的短语结构分析］对句法树中的每个非终结符都利用其中心词（词性）标注，通过马尔可夫过程求解</li>
  <li>［非词汇化句法分析］上下文无关的假设离现实存在距离，加入隐含标记</li>
  <li>［短语结构分析器性能评价］标记正确率、标记召回率、交叉括号数
    <ul>
      <li>英语句子的分析准确率已超过90%</li>
      <li>汉语的性能约低5%</li>
    </ul>
  </li>
  <li>［长句结构分析］通常算法时间复杂度为$O(N^3)$，局部子句的错误会导致常聚得不到正确的句法关系树
    <ul>
      <li>利用标点符号切分单元</li>
    </ul>
  </li>
  <li>［HP算法］Hierarchical Parsing，层次分析
    <ul>
      <li>依据标点分割长句</li>
      <li>对各子句分别句法分析</li>
      <li>第二遍分析得到子句结构关系</li>
    </ul>
  </li>
  <li>［浅层句法分析］又称部分句法分析、语块划分，仅要求识别句子中某些结构相对简单的独立成分
    <ul>
      <li>［基本名词短语］短语的中心语为名词，短语中不含有其他子项短语；可采用括号分隔法或IOB标注方法</li>
      <li>常用方法同样有基于统计和基于规则的，包括SVM、WINNOW、CRF</li>
    </ul>
  </li>
  <li>［依存语法］句子中词与词间的依存关系，又称为从属关系语法，词之间关系不对等，存在支配关系
    <ul>
      <li>依存树是一颗有“根”树</li>
      <li>依存分析方法包括生成式、判别式和确定式
        <ul>
          <li>生成式和判别式是机器学习两类达模型的拓展应用</li>
          <li>确定性分析策略包括“依次读入”和“立即处理”</li>
        </ul>
      </li>
      <li>汉语依存分析性能效果较英语差许多</li>
      <li>短语结构树可对应转换成依存关系树</li>
    </ul>
  </li>
</ul>

<h2 id="第9章-语义分析">第9章 语义分析</h2>
<ul>
  <li>［词义消歧］确定一个多义词在上下文语境中的具体含义，也称为词义标注</li>
  <li>［有监督的词义消歧］利用有监督的机器学习解决词义消歧问题（分类问题）
    <ul>
      <li>［基于互信息方法］利用Flip-Flop算法，迭代找到最佳的互信息</li>
      <li>［基于贝叶斯分类器方法］朴素贝叶斯假设词间独立，极大似然方式估计</li>
      <li>［基于最大熵方法］示例特征包括词形信息、词性信息、词形及词性信息</li>
    </ul>
  </li>
  <li>［基于词典的词义消歧］结合本身词典信息，如Yarowsky算法</li>
  <li>［无监督的词义消歧］通过词义辨识进行，随机赋值并利用EM算法估计</li>
  <li>词义消歧目前算法在正确率和召回率不到80%</li>
  <li>［语义角色标注］浅层语义分析技术，以句子为单位，分析谓词－论元结构，即各成分与谓词的关系
    <ul>
      <li>受句法分析的准确率影响大，每一个论元相应于句法树的某个节点</li>
      <li>［基本流程］假定谓词给定，进行句法分析，剪除候选论元，论元辨识与标注，处理后得到标注结果</li>
      <li>不同语义角色标注方法区别在于利用的句法分析树不同</li>
      <li>为了减轻句法分析错误，可以对多个语义角色标注系统的结果进行融合</li>
      <li>汉语语义角色标注F1超过70%，融合方法F1达到80%</li>
      <li>语义角色标注在领域内外测试集的F1差距一般在10％上下</li>
    </ul>
  </li>
  <li>［双语联合语义角色标注］联合推断模型可采用整数线性规划，涉及三部分包括源语言、目标语言和双语两端的论元对齐
    <ul>
      <li>双语联合推断模型的目标函数是三个子目标函数的加权和</li>
    </ul>
  </li>
</ul>

<h2 id="第10章-篇章分析">第10章 篇章分析</h2>
<ul>
  <li>篇章分析最终目的从整体上理解篇章，核心任务分析篇章结构
    <ul>
      <li>篇章结构包括逻辑语义结构、指代结构、话题结构</li>
      <li>［篇章的基本特征］衔接性、连贯性、意图性、信息性、可接受性、情景性和跨篇章性</li>
    </ul>
  </li>
  <li>篇章分析理论，最早为概念依存方法，提出脚本方法基于场景填入slot
    <ul>
      <li>［言语行为理论］语言不是用来陈述事实或描述事物的，而是负载着言语者的意图；包括言内行为、言外行为和言后行为</li>
      <li>［中心理论］篇章由三个分离的但相互关联的部分组成，包括话语序列结构、目的结构和关注焦点状态</li>
      <li>［修辞结构理论］描述各部分的修辞关系来分析篇章结构和功能，提出两种篇章单位，为核心和卫星</li>
      <li>［脉络理论］建立在中心理论和修辞结构理论之上，拓展到宏观语篇，但只关心拓扑结构</li>
      <li>［篇章表示理论］篇章是自然语言理解的完整单位，构造篇章表示结构，包括篇章指称对象和与指称对象有关的条件</li>
    </ul>
  </li>
  <li>［篇章衔接性］衔接即外部联结，整个篇章范围内词汇（或短语）之间的关联
    <ul>
      <li>指代一般包括回指和共指，指代消歧是衔接性研究的关键问题</li>
    </ul>
  </li>
  <li>［篇章连贯性］句子之间的语义关联，又称内部联结，研究主要在信息性和意图性两方面
    <ul>
      <li>［篇章信息性］对于接受者，篇章提供的信息超过或低于期望值的程度</li>
      <li>［篇章意图性］篇章结构理论不应只考虑篇章内容，还应解释其中意图</li>
      <li>汉语重语义，篇章语义主导，衔接性重于连贯性；英语重结构，篇章结构主导，连贯性重于衔接性</li>
    </ul>
  </li>
  <li>汉语篇章分析具有“句群”这个本土特征</li>
</ul>

<h2 id="第11章-统计机器翻译">第11章 统计机器翻译</h2>
<ul>
  <li>［机器翻译方法］基于规则的转换翻译、基于中间语言的翻译方法、基于语料库的翻译方法（包括基于记忆的、基于实例的、基于统计的、基于神经网络的）</li>
  <li>［噪声信道模型］翻译系统被看作是噪声信道，对一个观察到的信道输出字串S，寻找最大可能的信道输入句子T，即求解T使$P(T|S)$最大
    <ul>
      <li>对于翻译模型$P(T|S)$的计算，核心使定义目标语言句子T的词与源语言句子S的词之间对应关系，要求“对齐”</li>
      <li>通过不同的假设，构建可计算的模型（以词为单位建模的IBM模型）</li>
      <li>对位模型是系统的核心，可以利用HMM建模优化</li>
    </ul>
  </li>
  <li>［基于短语的模型］如果双语句子中的某些单词序列具有相同的语义，形成的短语具有相同的短语类，那么认为对应的单词序列是对齐的短语
    <ul>
      <li>这类模型是最为成熟的统计机器翻译技术</li>
    </ul>
  </li>
  <li>……</li>
</ul>

<h2 id="第12章-语音翻译">第12章 语音翻译</h2>
<ul>
  <li>［语音翻译核心模块］主要由自动语音识别器（ASR）、机器翻译引擎（MT）和语音合成器（TTS）串行顺序连接组成</li>
  <li>……</li>
</ul>

<h2 id="第13章-文本分类与情感分类">第13章 文本分类与情感分类</h2>
<ul>
  <li>［文本自动分类系统］主要有两种类型，基于知识工程（KE）的分类系统和基于机器学习（ML）的分类系统</li>
  <li>［文本表示］通常采用向量空间模型（VSM），即把文本转化成特定特征的多维度向量
    <ul>
      <li>相似性度量多用内积即余弦值表示</li>
      <li>在VSM表示文前，需要进行词汇化处理，汉语主要依赖分词技术，可用语言无关性的n元语法简化处理</li>
      <li>除向量空间模型外，还有词组表示法、概念表示法（WordNet与HowNet）等</li>
    </ul>
  </li>
  <li>［文本特征］常用的特征选取方法包括基于文档频率的特征提取法、信息增益法、卡方统计量法和互信息法等
    <ul>
      <li>核心是依据一定标准“筛选”特征，降低输入空间的维度，同时要尽量减少噪声</li>
    </ul>
  </li>
  <li>［特征权重］衡量某个特征的重要程度或区分能力的强弱，通常利用文本的统计信息</li>
  <li>［分类器设计］常用的分类算法包括：朴素贝叶斯、SVM、kNN、ANN、决策树、模糊分类、Roccino分类、Boosting等</li>
  <li>［分类性能指标］召回率、正确率、F-测度值、微平均和宏平均、平衡点、11点平均正确率</li>
  <li>［情感分类］较一般的分类问题，具有情感信息表达的隐蔽性、多义性和极性不明显等特征</li>
</ul>

<h2 id="第14章-信息检索与问答系统">第14章 信息检索与问答系统</h2>
<ul>
  <li>［信息检索］起源于图书馆的资料查询和文摘索引工作，关键技术包括标引（indexing）和相关度（relevance）计算
    <ul>
      <li>估计用户查询标引和候选查询文本之间相关度的模型通常包括：布尔模型、向量空间模型、概率模型和语言模型</li>
      <li>大多数信息检索系统都建立主要数据的倒排索引实现快速检索</li>
    </ul>
  </li>
  <li>［隐含语义标引模型］（LSI）建立查询文字与文档之间的语义概念关联
    <ul>
      <li>采用SVC对词项－文档关联矩阵分解</li>
      <li>通过EM迭代，估计PLSI中条件概率等，引入隐含“话题”</li>
      <li>SPLSI基于PLSI，先展开预聚类</li>
    </ul>
  </li>
  <li>［信息检索评测指标］主要包括准确率、召回率、F测度值、P@10、R－precision和最差x％</li>
  <li>［回答系统］能够接受用户以自然语言形式描述的提问，并从大量异构数据中查找或推断出用户问题答案的信息检索系统
    <ul>
      <li>可划分为基于固定语料库的问答系统、网络问答系统和单文本问答系统</li>
      <li>自动回答系统通常由提问处理模块、检索模块和答案抽取模块三部分</li>
      <li>问答技术大致分为四种类型：基于检索的问答技术、基于模式匹配的问答技术、基于自然语言理解的问答技术和基于统计翻译模型的问答技术</li>
    </ul>
  </li>
</ul>

<h2 id="第15章-自动文摘与信息抽取">第15章 自动文摘与信息抽取</h2>
<ul>
  <li>［自动文摘］利用计算机自动实现文本分析、内容归纳合摘要自动生成的技术</li>
  <li>［多文档摘要］将同一主题下多个文本描述的主要信息按压缩比提炼出一个文本
    <ul>
      <li>通常采用基于抽取的方法和基于理解的方法</li>
      <li>缺乏自动评测方法，通常关注召回、准确、冗余、偏差</li>
    </ul>
  </li>
  <li>［信息抽取］自动抽取指定类型的实体、关系、事件等事实信息，并形成结构化数据输出</li>
</ul>

<h2 id="第16章-口语信息处理与人机对话系统">第16章 口语信息处理与人机对话系统</h2>
<ul>
  <li>［汉语口语］词长分布集中于1字词和2字词，会出现省略、独词句等非规范语言现象</li>
  <li>情感表达的主要词类包括形容词、动词和名词</li>
  <li>［口语解析器］语音翻译系统和人机对话系统中的核心模块
    <ul>
      <li>［中间表示格式］特定的信息表示方式，如IF格式通常包括说话者、话语行为、概念序列和参数－属性值对</li>
      <li>［基于规则和HMM的统计解析方法］包括词汇分类、语义组块分析、统计解析、语义组块解释、IF生成数个模块</li>
      <li>［基于语义决策树］包括训练模块和解析模块；前者生成语义分类树和统计模型，后者利用上述模型对输入句子解析获得领域行为</li>
    </ul>
  </li>
  <li>［口语生成方法］采用基于模版的方法和基于特征的深层生成方法相结合的混合生成方法，包括微观规划器、表层生成器和后处理模块</li>
  <li>对话管理模块是系统的核心，基于对话历史调度人机交互机制，辅助语言解析器对语音识别结果进行正确的理解，为问题求解提供帮助，并指导语言的生成过程</li>
</ul>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2013-10-26T00:00:00+08:00"><a href="http://localhost:4000/background-image/">October 26, 2013</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About BenSuuun">BenSuuun</a></span></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/background-image/" rel="bookmark" title="Post with a Background Image" itemprop="url">Post with a Background Image</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Here be a sample post with a custom background image. To utilize this “feature” just add the following YAML to a post’s front matter.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">image</span><span class="pi">:</span>
  <span class="na">background</span><span class="pi">:</span> <span class="s">filename.png</span>
</code></pre></div></div>

<p>This little bit of YAML makes the assumption that your background image asset is in the <code class="highlighter-rouge">/images</code> folder. If you place it somewhere else or are hotlinking from the web, just include the full http(s):// URL. Either way you should have a background image that is tiled.</p>

<p>If you want to set a background image for the entire site just add <code class="highlighter-rouge">background: filename.png</code> to your <code class="highlighter-rouge">_config.yml</code> and BOOM — background images on every page!</p>

<div xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/" about="http://subtlepatterns.com" class="notice">Background images from <span property="dct:title">Subtle Patterns</span> (<a rel="cc:attributionURL" property="cc:attributionName" href="http://subtlepatterns.com">Subtle Patterns</a>) / <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a></div>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    

    
    
      <li><strong class="current-page">1</strong></li>
    

    
    

    
    
    

    

    
    

    
      <li><a href="http://localhost:4000/page2/">2</a></li>
    

    
    
      <li><a href="http://localhost:4000/page2/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 BenSuuun. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        showProcessingMessages: false, //关闭js加载过程信息
        messageStyle: "none", //不显示信息
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ], //行内公式选择符
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ], //段内公式选择符
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'], //避开某些标签
            ignoreClass:"comment-content" //避开含该Class的标签
        },
        "HTML-CSS": {
            availableFonts: ["STIX","TeX"], //可选字体
            showMathMenu: false //关闭右击菜单显示
        }
    });
    MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    </script>
    <script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



          

</body>
</html>