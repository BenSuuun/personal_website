---
layout: post
title: "LeetCode #81~#100"
description: "Codes and notes on LeetCode #81~#100"
tags: [algorithm, python, leetcode]
image:
  path: /images/abstract-4.jpg
  feature: abstract-4.jpg
---

## #81 Search in Rotated Sorted Array II

### 二分查找
首先二分查找翻转点，即当前元素大于下一元素的点，由于元素可重复，可能涉及到双分支均需搜索的情况。在搜索到翻转点后，判断目标元素与数组首元素的大小关系，依此确定二分查找该元素的具体分支  
时间$O(\log n)$  
空间$O(n)$  
```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        def binary_rot(i: int, j: int) -> int:
            mid = (i + j) // 2
            if mid+1 < len(nums) and nums[mid] > nums[mid+1]:
                return (mid)
            if i >= j:
                return (-1)
            if nums[j] > nums[i]:
                return (-1)
            if nums[mid] >= nums[i]:
                tmp = binary_rot(mid+1, j)
                if tmp != -1:
                    return (tmp)
            if nums[mid] <= nums[j]:
                tmp = binary_rot(i, mid)
                if tmp != -1:
                    return (tmp)
            return (tmp)
        
        if not nums:
            return (False)
        rot_point = binary_rot(0, len(nums) - 1)
        if rot_point == -1:
            rot_point = len(nums) - 1
        i = 0
        j = len(nums) - 1
        if target < nums[0]:
            i = min(rot_point+1, len(nums) - 1)
        elif target > nums[0]:
            j = rot_point
        else:
            return (True)
        while i <= j:
            mid = (i + j) // 2
            if nums[mid] == target:
                return (True)
            elif nums[mid] > target:
                j = mid - 1
            else:
                i = mid + 1
        return (False)
```

### Tip
* 注意corner case，如空集、单元素等情形
* 二分查找可以通过模拟判断细节