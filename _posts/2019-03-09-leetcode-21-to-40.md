---
layout: post
title: "LeetCode #21~#40"
description: "Codes and notes on LeetCode #21~#40"
tags: [algorithm, python, leetcode]
image:
  path: /images/abstract-7.jpg
  feature: abstract-7.jpg
---

## #21 Merge Two Sorted Lists

### 双链表指针比较
链表上各放置一指针，判断当前位置的大小关系，将较小者加入结果链表。最后，各链表剩余的元素加入结果链表。 
时间$O(n)$  
空间$O(n)$  
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = ListNode(-1)
        pointer = head
        while l1 and l2:
            if l1.val <= l2.val:
                pointer.next = ListNode(l1.val)
                pointer = pointer.next
                l1 = l1.next
            else:
                pointer.next = ListNode(l2.val)
                pointer = pointer.next
                l2 = l2.next
        while l1:
            pointer.next = ListNode(l1.val)
            pointer = pointer.next
            l1 = l1.next
        while l2:
            pointer.next = ListNode(l2.val)
            pointer = pointer.next
            l2 = l2.next
        return head.next
```

### Tip
* 非空的元素bool判断为真

## #22 Generate Parentheses

### 模拟栈剪枝
模拟一个保存左括号的栈，只有在栈里还有元素时才能出栈并配对右括号。使用深度搜索来便利各种情况，并利用栈来判断是否合法并剪枝  
时间$O(n^2)$  
空间$O(n^2)$
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        output = []
        def stackSearch(n: int, s: int, comb: str):
            if n == 0:
                output.append(comb)
                return
            if s == 0:
                stackSearch(n, s+1, comb+'(')
                return
            if n > s:
                stackSearch(n-1, s-1, comb+')')
                stackSearch(n, s+1, comb+'(')
            else:
                stackSearch(n-1, s-1, comb+')')
        
        stackSearch(n, 0, "")
        return output
```

### Tip
* 写类内函数时，注意平行关系的函数间需要加入self。同时，设置类内“全局”变量时也要加上self前缀
* 类内函数可以嵌套函数，此时无需加入self,一般对待即可

