---
layout: post
title: "LeetCode #21~#40"
description: "Codes and notes on LeetCode #21~#40"
tags: [algorithm, python, leetcode]
image:
  path: /images/abstract-7.jpg
  feature: abstract-7.jpg
---

## #21 Merge Two Sorted Lists

### 双链表指针比较
链表上各放置一指针，判断当前位置的大小关系，将较小者加入结果链表。最后，各链表剩余的元素加入结果链表。 
时间$O(n)$  
空间$O(n)$  
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = ListNode(-1)
        pointer = head
        while l1 and l2:
            if l1.val <= l2.val:
                pointer.next = ListNode(l1.val)
                pointer = pointer.next
                l1 = l1.next
            else:
                pointer.next = ListNode(l2.val)
                pointer = pointer.next
                l2 = l2.next
        while l1:
            pointer.next = ListNode(l1.val)
            pointer = pointer.next
            l1 = l1.next
        while l2:
            pointer.next = ListNode(l2.val)
            pointer = pointer.next
            l2 = l2.next
        return head.next
```

### Tip
* 非空的元素bool判断为真

## #22 Generate Parentheses

### 模拟栈剪枝
模拟一个保存左括号的栈，只有在栈里还有元素时才能出栈并配对右括号。使用深度搜索来便利各种情况，并利用栈来判断是否合法并剪枝  
时间$O(n^2)$  
空间$O(n^2)$
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        output = []
        def stackSearch(n: int, s: int, comb: str):
            if n == 0:
                output.append(comb)
                return
            if s == 0:
                stackSearch(n, s+1, comb+'(')
                return
            if n > s:
                stackSearch(n-1, s-1, comb+')')
                stackSearch(n, s+1, comb+'(')
            else:
                stackSearch(n-1, s-1, comb+')')
        
        stackSearch(n, 0, "")
        return output
```

### Tip
* 写类内函数时，注意平行关系的函数间需要加入self。同时，设置类内“全局”变量时也要加上self前缀
* 类内函数可以嵌套函数，此时无需加入self,一般对待即可

## #23 Merge k Sorted Lists

### 堆/优先队列优化
维护一个堆结构，每个队列在其中有一个元素，弹出最小元素后，判断其是否有后继，有的话再加入堆并调整结构  
时间$O(n\log k)$  
空间$O(n)$
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        heapQueue = []
        for node in lists:
            if not node:
                continue
            i = len(heapQueue)+1
            heapQueue.append(node)
            while i//2-1 >= 0 and heapQueue[i//2-1].val > node.val:
                heapQueue[i-1] = heapQueue[i//2-1]
                i = i // 2
            heapQueue[i-1] = node
        headOutput = ListNode(-1)
        pointer = headOutput
        while len(heapQueue) > 0:
            pointer.next = heapQueue[0]
            pointer = pointer.next
            if pointer.next:
                heapQueue[0] = pointer.next
            else:
                heapQueue[0] = heapQueue[-1]
                heapQueue.pop()
            i = 1
            if len(heapQueue) == 0:
                break
            node = heapQueue[0]
            while True:
                if 2 * i > len(heapQueue):
                    heapQueue[i-1] = node
                    break
                if 2 * i == len(heapQueue) or \
                heapQueue[2*i-1].val < heapQueue[2*i].val:
                    if heapQueue[2*i-1].val < node.val: 
                        heapQueue[i-1] = heapQueue[2*i-1]
                        i = 2 * i
                    else:
                        heapQueue[i-1] = node
                        break
                else:
                    if heapQueue[2*i].val < node.val: 
                        heapQueue[i-1] = heapQueue[2*i]
                        i = 2 * i + 1
                    else:
                        heapQueue[i-1] = node
                        break
        return headOutput.next
```

### Tip
* python中优先队列可用Queue.PriorityQueue实现，可考虑改写其中部分组块
* 考虑输入为空集的情形
* 使用List实现类似树结构时，注意下标细节