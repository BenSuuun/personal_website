---
layout: post
title: "LeetCode #61~#80"
description: "Codes and notes on LeetCode #61~#80"
tags: [algorithm, python, leetcode]
image:
  path: /images/abstract-5.jpg
  feature: abstract-5.jpg
---

## #61 Rotate List

### 模拟
首先评估链表长度，随后判断有效的翻转次数，根据模拟规则确定节点前后关系  
时间$O(n)$  
空间$O(n)$

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if not head:
            return (head)
        pointer = head
        length = 1
        while pointer.next:
            length += 1
            pointer = pointer.next
        rear = pointer
        effective_rotate = k % length
        if not effective_rotate:
            return (head)
        pointer = head
        for i in range(length - effective_rotate - 1):
            pointer = pointer.next
        new_head = pointer.next
        pointer.next = rear.next
        rear.next = head
        return (new_head)
```

### Tip
* 注意链表的位置细节
* 判断边界值

## #62 Unique Paths

### 动态规划
记$dp[i, j]$为抵达第i行第j列的路径数，转移方程为$dp[i, j] = dp[i - 1, j] + dp[i, j - 1]$，其中超边界值为0，初始值$dp[0, 0] = 1$，可以使用覆盖更新避免内存占用过大  
时间$O(mn)$  
空间$O(m)$
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        if m == 0 or n == 0:
            return (0)
        dp = [1] * m
        for row in range(n - 1):
            for column in range(1, m):
                dp[column] = dp[column] + dp[column - 1]
        return (dp[m - 1])
```

### Tip
* 动态规划关注存储空间的优化可能性

## #63 Unique Paths II

### 动态规划
定义及转移方程类似#62，加入障碍物的限制，当前元素为障碍物的话直接将dp赋值为0  
时间$O(mn)$  
空间$O(n)$ 
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if len(obstacleGrid) == 0 or len(obstacleGrid[0]) == 0:
            return (0)
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        dp = [0] * n
        dp[0] = 1
        for i in range(m):
            if obstacleGrid[i][0] == 1:
                dp[0] = 0
            for j in range(1, n):
                dp[j] = dp[j] + dp[j - 1]
                if obstacleGrid[i][j] == 1:
                    dp[j] = 0
        return (dp[n - 1])
```

### Tip
* 复杂变量的拼写情况

## #64 Minimum Path Sum

### 动态规划
类似#62与#63，转移方程调整为$dp[i, j] = \min(dp[i-1, j], dp[i, j-1]) + grid[i, j]$  
时间$O(mn)$  
空间$O(n)$
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        dp = [1e10] * n
        dp[0] = 0
        for i in range(m):
            dp[0] = dp[0] + grid[i][0]
            for j in range(1, n):
                dp[j] = min(dp[j], dp[j - 1]) + grid[i][j]
        return (dp[n - 1])
```

### Tip
* 初始值和边界值的处理

## #65 Valid Number

### 规则判断
逐位依规则判断，注意边界值  
时间$O(n)$  
空间$O(n)$

```python
class Solution:
    def isNumber(self, s: str) -> bool:
        valid_symbol = set(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                          '+', '-', 'e', '.', ' '])
        number = set(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'])
        if not s:
            return (False)
        for i in range(len(s)):
            if s[i] not in valid_symbol:
                return (False)
        start = 0
        while start < len(s) and s[start] == ' ':
            start += 1
        if start == len(s):
            return (False)
        end = len(s) - 1
        while s[end] == ' ':
            end -= 1
        if s[start] in ['+', '-']:
            start += 1
        pointer = start
        while pointer <= end and s[pointer] in number:
            pointer += 1
        if pointer == end + 1:
            return (True)
        if s[pointer] == '.':
            pointer += 1
            while pointer <= end and s[pointer] in number:
                pointer += 1
            if pointer == start + 1:
                return (False)
            if pointer == end + 1:
                return (True)
        if start == pointer:
            return (False)
        if s[pointer] == 'e':
            if pointer == end:
                return (False)
            pointer += 1
            if s[pointer] in ['+', '-']:
                if pointer == end or s[pointer + 1] not in number:
                    return (False)
                pointer += 1
            tmp_pointer = pointer
            while pointer <= end and s[pointer] in number:
                pointer += 1
            if pointer == end + 1:
                return (True)
        return (False)
```

### Tip
* 注意这些case: .1, 01, 3., .

## #66 Plus One

### 模拟计算
在末尾加上1，随后不断判断是否进位，最后在首位判断是否需要增加一位  
时间$O(n)$  
空间$O(n)$
```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        digits[-1] += 1
        i = len(digits) - 1
        while i > 0 and digits[i] > 9:
            digits[i] = 0
            digits[i - 1] += 1
            i -= 1
        if digits[0] > 9:
            digits[0] = 0
            digits = [1] + digits
        return (digits)
```

### Tip
* 注意结束条件与结束状态的合法性

## #67 Add Binary

### 模拟计算
直接对应位相加，随后通过进位得到合法二进制表达  
时间$O(n)$  
空间$O(n)$
```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        a = a[::-1]
        b = b[::-1]
        i = 0
        output = []
        while i < len(a) and i < len(b):
            output.append(int(a[i]) + int(b[i]))
            i += 1
        while i < len(a):
            output.append(int(a[i]))
            i += 1
        while i < len(b):
            output.append(int(b[i]))
            i += 1
        for j in range(i - 1):
            output[j + 1] += output[j] // 2
            output[j] = output[j] % 2
        print (output)
        j = i - 1
        while output[j] > 1:
            output.append(output[j] // 2)
            output[j] = output[j] % 2
            j += 1
        output_s = ''
        for i in range(j + 1):
            output_s = str(output[i]) + output_s
        return (output_s)
```

### Tip
* 注意索引与数组长度的细节
* 注意while与if的使用

## #68 Text Justification

### 模拟计算
依据题目条件，贪婪选择单行单词数，并依照要求格式排布，考虑特殊情况例如单行仅有一单词或已到结尾，作出相应的调整即可  
时间$O(n)$  
空间$O(n)$

```python
import math
class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        i = 0
        output = []
        while i < len(words):
            start = i
            width = len(words[i])
            while (i < len(words) - 1 and 
                   width+len(words[i+1])+i-start+1 <= maxWidth):
                i += 1
                width += len(words[i])
            space = maxWidth - width
            space_num = i - start
            tmp = words[start]
            if space_num == 0:
                tmp += ' ' * (maxWidth - len(tmp))
            elif i == len(words) - 1:
                for j in range(space_num):
                    tmp += ' '
                    tmp += words[start + j + 1]
                tmp += ' ' * (maxWidth - len(tmp))
            else:
                for j in range(space_num):
                    cur_space = math.ceil(space / (space_num - j))
                    tmp += ' ' * cur_space
                    space -= cur_space
                    tmp += words[start + j + 1]
            output.append(tmp)
            i += 1
        return (output)
```

### Tip
* 模拟的代码可以按步骤依次debug

## #69 Sqrt(x)

### 二分查找
二分查找其根值，注意使用向上取整的中间值，仅右侧有缩区间的行为  
时间$O(\log n)$  
空间$O(1)$
```python
import math
class Solution:
    def mySqrt(self, x: int) -> int:
        i = 0
        j = x
        while i < j:
            mid = math.ceil((i + j) / 2)
            if mid * mid < x:
                i = mid
            elif mid * mid > x:
                j = mid - 1
            elif mid * mid == x:
                i = mid
                j = mid
        return (i)
```

### Tip
* 注意判断中值选择与区间变化情况

## #70 Climbing Stairs

### 动态规划
转移方程$dp[i] = dp[i - 1] + dp[i - 2]$，初始条件$dp[1] = 1,dp[2]=2$。事实上，这是一个斐波那契数列  
时间$O(n)$  
空间$O(1)$
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        n1 = 1
        n2 = 2
        if n == 1:
            return (1)
        for i in range(3, n+1):
            tmp =n1 + n2
            n1 = n2
            n2 = tmp
        return (n2)
```

### Tip
* 注意动态规划的初始条件设置

## #71 Simplify Path

### 栈实现
对输入路径依据'/'切分，随后判断其值是否为空，是否等于'.'，是否等于'..'，并对栈进行维护。考虑特殊情形栈为空及输出  
时间$O(n)$  
空间$O(n)$
```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        path_split = path.split('/')
        for i in range(len(path_split)):
            if len(path_split[i]) == 0:
                continue
            elif path_split[i] == '.':
                continue
            elif path_split[i] == '..':
                if len(stack) > 0:
                    stack.pop(-1)
            else:
                stack.append(path_split[i])
        output = ''
        if len(stack) == 0:
            output = '/'
        for i in range(len(stack)):
            output = output + '/' + stack[i]
        return (output)
```

### Tip
* 使用队列与栈这类数据结构时，关注空的情形

## #72 Edit Distance

### 动态规划
$dp[i, j]$记为串1前i个字符，串2前j个字符匹配上的最小的编辑距离，转移方程$dp[i, j] = \min\{dp[i-1, j] + 1, dp[i, j-1] + 1, dp[i - 1, j - 1] + 1 - \{s1[i] == s2[j]\}\}$,分别对应删除，插入和替换三种操作，初始条件$dp[i, 0] = i, dp[0, j] = j$。可以通过滚动数组降低空间开销  
时间$O(mn)$  
空间$O(m)$
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        dp = list(range(len(word2) + 1))
        for i in range(1, len(word1) + 1):
            former_dp = dp[:]
            dp[0] = i
            for j in range(1, len(word2) + 1):
                tmp = min(former_dp[j] + 1, dp[j - 1] + 1)
                if word1[i - 1] == word2[j - 1]:
                    tmp = min(tmp, former_dp[j - 1])
                else:
                    tmp = min(tmp, former_dp[j - 1] + 1)
                dp[j] = tmp
        return (dp[len(word2)])
```

### Tip
* 字符串处理注意其长度与下标的关系