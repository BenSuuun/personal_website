---
layout: post
title: "LeetCode #1~#20"
description: "Codes and notes on LeetCode #1~#20"
tags: [algorithm, python, leetcode]
image:
  path: /images/abstract-9.jpg
  feature: abstract-9.jpg
---

## #1 Two Sum

### 暴力求解 
时间$O(n^2)$  
空间$O(1)$  
双层嵌套循环遍历数组，直至找到结果
```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return ([i, j])
```

### 排序后求解
时间$O(n\log n)$  
空间$O(1)$  
选择该复杂度的排序算法，如快速排序；随后两端双指针相向遍历

### *Hash求解
时间$O(n)$  
空间$O(n)$  
将数据映射入hash表；遍历数值，并在hash表中寻找差值
```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        hashTable = {}
        # python中dict以hash table方法实现
        for i in range(len(nums)):
            hashTable[nums[i]] = i
        for i in range(len(nums)):
            res = target - nums[i]
            if res in hashTable and hashTable[res] != i:
                return ([i, hashTable[res]])
        raise Exception('No solution')
        #异常处理
```

### Tip
* 关注异常情况的处理
* 了解语言内建数据结构的实现方法
    * python中[dictionary](https://mail.python.org/pipermail/python-list/2000-March/048085.html)以hash table方法实现 

## #2 Add Two Numbers

### 逐位运算
时间$O(n)$  
空间$O(n)$  
两个链表上定义指针，逐位运算，考虑进位情况
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        p1 = l1
        p2 = l2
        lr = ListNode(None)
        pr = lr
        incre = 0
        while p1 != None and p2 != None:
            tmp = incre + p1.val + p2.val
            incre = tmp // 10
            tmp = tmp % 10
            pr.next = ListNode(tmp)
            pr = pr.next
            p1 = p1.next
            p2 = p2.next
        while p1 != None:
            tmp = incre + p1.val
            incre = tmp // 10
            tmp = tmp % 10
            pr.next = ListNode(tmp)
            pr = pr.next
            p1 = p1.next
        while p2 != None:
            tmp = incre + p2.val
            incre = tmp // 10
            tmp =tmp % 10
            pr.next = ListNode(tmp)
            pr = pr.next
            p2 = p2.next
        if incre != 0:
        #当最后有进位时
            pr.next = ListNode(incre)
        return (lr.next)
```

### *逐位运算-简化
时间$O(n)$  
空间$O(n)$  
利用bool()的性质，仅在0、None或空集情况下为False
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        lr = ListNode(None)
        pr = lr
        incre = 0
        while incre or l1 or l2:
            #bool性质
            tmp = 0
            if l1:
                tmp += l1.val
                l1 = l1.next
            if l2:
                tmp += l2.val
                l2 = l2.next
            tmp += incre
            incre = tmp // 10
            tmp = tmp % 10
            pr.next = ListNode(tmp)
            pr = pr.next
        return (lr.next)
```

### Tip
* 类之间的[赋值](https://www.cnblogs.com/jiangzhaowei/p/5740913.html)与指针引用的关系
    * 函数中，不可变值与可变值传递有区别，都可认为是“局部变量”即传入变量的指针不变，但后者传递的指针引用可在函数中修改值
    * python的变量都可看作是指针
* 考虑边界情况