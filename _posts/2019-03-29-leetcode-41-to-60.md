---
layout: post
title: "LeetCode #41~#60"
description: "Codes and notes on LeetCode #41~#60"
tags: [algorithm, python, leetcode]
image:
  path: /images/abstract-2.jpg
  feature: abstract-2.jpg
---

## #41 First Missing Positive

### 链式替换
考虑时间要求是仅读取一遍，且空间要求不能利用额外的数组，需要在原数组上更改。依次检查每个单元格的值，是否等于其index，若不等于，则链式访问其所指示的位置。当特定元素不满足数组长度内的正整数要求时，结束链式寻找，并访问下一个单元格  
时间$O(n)$  
空间$O(1)$  
```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        for position in range(len(nums)):
            pointer = position
            tmp = nums[pointer]
            while nums[pointer] != pointer+1:
                tmp_next = nums[pointer]
                nums[pointer] = tmp
                if tmp_next < 1 or tmp_next > len(nums):
                    break
                pointer = tmp_next - 1
                tmp = tmp_next
        position = 0
        while position < len(nums) and nums[position] == position + 1:
            position += 1
        return (position + 1)
```

### Tip
* 依据限制，思考经典的处理方法，进行适当修改