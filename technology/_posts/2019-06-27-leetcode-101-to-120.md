---
layout: post
title: "LeetCode #101~#120"
description: >
    Leetcode #101~#120的代码与求解思路
image: /assets/img/blog/abstract-6.jpg
---
按照题目编号排序，一些题目包含不止一个思路

# #101 Symmetric Tree

## 递归遍历
判断左右子树是否对称，递归方式遍历  
时间$$O(n)$$  
空间$$O(\log n)$$  
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if root is None:
            return (True)
        return (self.isSame(root.left, root.right))
    
    def isSame(self, a: TreeNode, b: TreeNode) -> bool:
        if not (a or b):
            return (True)
        if not (a and b):
            return (False)
        if a.val != b.val:
            return (False)
        return (self.isSame(a.left, b.right) and self.isSame(a.right, b.left))
```

## Tip
* 注意节点为None的处理

# #102 Binary Tree Level Order Traversal

## 队列层次遍历
遍历当前层次，并将其可行的子节点加入新队列，直到新队列为空  
时间$$O(n)$$  
空间$$O(n)$$  
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if root is None:
            return ([])
        output = []
        queue = [root]
        while queue:
            new_queue = []
            val_record = []
            for node in queue:
                val_record.append(node.val)
                if node.left:
                    new_queue.append(node.left)
                if node.right:
                    new_queue.append(node.right)
            output.append(val_record)
            queue = new_queue[:]
        return (output)
```

## Tip
* 需要分割上一层队列与下一层队列

# #103 Binary Tree Zigzag Level Order Traversal

## 队列层次遍历
类似#102遍历当前层次，并将其可行的子节点加入新队列，直到新队列为空。此外，维护一bool判断当前层次是否需要逆序    
时间$$O(n)$$  
空间$$O(n)$$  
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if root is None:
            return ([])
        queue = [root]
        output = []
        flag = True
        while queue:
            val_list = []
            new_queue = []
            for node in queue:
                val_list.append(node.val)
                if node.left:
                    new_queue.append(node.left)
                if node.right:
                    new_queue.append(node.right)
            queue = new_queue[:]
            if flag:
                output.append(val_list[:])
                flag = False
            else:
                output.append(val_list[::-1])
                flag = True
        return (output)
```

## Tip
* 层次逆序需考虑左子树和右子树本身的逆序

# #104 Maximum Depth of Binary Tree

## 队列层次遍历
类似#102遍历当前层次，并将其可行的子节点加入新队列，直到新队列为空。此外，统计遍历的层次数记为深度  
时间$$O(n)$$  
空间$$O(n)$$  
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return (0)
        queue = [root]
        level = 0
        while queue:
            level += 1
            new_queue = []
            for node in queue:
                if node.left:
                    new_queue.append(node.left)
                if node.right:
                    new_queue.append(node.right)
            queue = new_queue[:]
        return (level)
```

## Tip
* 注意节点为None时的处理

# #105 Construct Binary Tree from Preorder and Inorder Traversal

## 递归构建
前序遍历的第一个点为当前子树的根节点。在中序遍历找到值对应的点后，在中序遍历左侧的元素位于左子树，右侧的元素位于右子树，随后递归构建整棵二叉树。  
时间$$O(n^2)$$  
空间$$O(n\log n)$$   
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder:
            return (None)
        node = TreeNode(preorder[0])
        i = inorder.index(preorder[0])
        node.left = self.buildTree(preorder[1:i+1], inorder[:i])
        node.right = self.buildTree(preorder[i+1:], inorder[i+1:])
        return (node)
```

## Tip
* 列表查找值避免用for语句，index效率能够高一些

# #106 Construct Binary Tree from Inorder and Postorder Traversal

## 递归构建
类似#105的方法，但根节点为后序遍历的最后一个元素。同样在中序遍历中找到该元素的位置，随后左右子树分别遍历构建。  
时间$$O(n^2)$$  
空间$$O(n\log n)$$  
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if not postorder:
            return (None)
        node = TreeNode(postorder[-1])
        pos = inorder.index(postorder[-1])
        node.left = self.buildTree(inorder[:pos], postorder[:pos])
        node.right = self.buildTree(inorder[pos+1:], postorder[pos:-1])
        return (node) 
```

## Tip
* 使用index提高检索效率

# #107 Binary Tree Level Order Traversal II

## 队列层次遍历
类似#102，维护队列记录下一层的节点，并将输出结果逆序即可  
时间$$O(n)$$  
空间$$O(n)$$  
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if root is None:
            return ([])
        queue = [root]
        val_list = []
        while queue:
            new_queue = []
            val_tmp = []
            for node in queue:
                val_tmp.append(node.val)
                if node.left:
                    new_queue.append(node.left)
                if node.right:
                    new_queue.append(node.right)
            queue = new_queue[:]
            val_list.append(val_tmp[:])
        return (val_list[::-1])
```

## Tip
* 形成完整的算法伪代码流后再实现，避免遗漏重要步骤

# #108 Convert Sorted Array to Binary Search Tree

## 递归构建
选取数组的中心作为当前的根节点，其左右分别作为左子树和右子树，递归构建二叉树  
时间$$O(n)$$  
空间$$O(n)$$  
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums:
            return (None)
        mid = len(nums) // 2
        node = TreeNode(nums[mid])
        node.left = self.sortedArrayToBST(nums[:mid])
        node.right = self.sortedArrayToBST(nums[mid+1:])
        return (node)
```

## Tip
* 注意空节点的处理